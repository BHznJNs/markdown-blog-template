{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///flowchart.min.js","webpack:///webpack/bootstrap 0c167881307e9f1b2ebf","webpack:///./index.js","webpack:///./src/flowchart.helpers.js","webpack:///./src/flowchart.symbol.js","webpack:///./src/flowchart.functions.js","webpack:///./src/flowchart.parse.js","webpack:///./src/flowchart.symbol.condition.js","webpack:///./src/flowchart.symbol.parallel.js","webpack:///./src/flowchart.chart.js","webpack:///./src/flowchart.defaults.js","webpack:///./src/flowchart.shim.js","webpack:///./src/flowchart.symbol.end.js","webpack:///./src/flowchart.symbol.input.js","webpack:///./src/flowchart.symbol.inputoutput.js","webpack:///./src/flowchart.symbol.operation.js","webpack:///./src/flowchart.symbol.output.js","webpack:///./src/flowchart.symbol.start.js","webpack:///./src/flowchart.symbol.subroutine.js","webpack:///./src/jquery-plugin.js","webpack:///external \"Raphael\""],"names":["root","factory","exports","module","require","define","amd","a","i","this","__WEBPACK_EXTERNAL_MODULE_18__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","parse","FlowChart","window","flowchart","_defaults","options","defaultOptions","merged","attrname","_inherits","ctor","superCtor","Object","super_","prototype","create","constructor","value","enumerable","writable","configurable","TempCtor","defaults","inherits","Symbol","chart","symbol","group","paper","set","connectedTo","symbolType","flowstate","lineStyle","key","leftLines","rightLines","topLines","bottomLines","params","next_direction","next","undefined","text","node","setAttribute","getAttr","attr","text-anchor","x","fill","font-size","font","fontF","fontW","font-family","font-weight","link","function","cursor","addEventListener","evt","target","maxWidth","words","split","tempText","ii","length","word","getBBox","width","substring","push","tmpMargin","stroke","stroke-width","height","roundness","isNaN","insertBefore","y","initialize","drawAPI","drawLine","checkLineIntersection","attName","opt1","opt3","opt2","symbols","transform","getCenter","getX","getY","shiftX","setX","shiftY","setY","getTop","getBottom","getLeft","getRight","render","self","lineLength","rightPoint","isPositioned","shift","symb","hasSymbolUnder","len","diff","Math","abs","leftPoint","bottomPoint","renderLines","drawLineTo","origin","indexOf","line","yOffset","right","bottom","top","left","symbolX","symbolY","symbolTop","symbolRight","symbolLeft","isOnSameColumn","isOnSameLine","isUnder","isUpper","isLeft","isRight","maxX","lineWith","max","rightStart","topEnd","bottomStart","diffX","leftStart","topStart","leftEnd","rightEnd","l","llen","lines","otherLine","ePath","lPath","iP","lenP","newPath","line1_from_x","line1_from_y","line1_to_x","line1_to_y","lP","lenlP","newLinePath","line2_from_x","line2_from_y","line2_to_x","line2_to_y","res","onLine1","onLine2","newSegment","splice","minXFromSymbols","maxXFromLine","drawPath","location","points","path","pathValues","from","to","toString","arrow-end","centerText","textPath","textAnchor","isHorizontal","firstTo","line1StartX","line1StartY","line1EndX","line1EndY","line2StartX","line2StartY","line2EndX","line2EndY","denominator","b","numerator1","numerator2","result","input","getStyle","s","startIndex","endIndex","getSymbValue","getSymbol","getNextPath","flowSymb","getAnnotation","tmp","tmp_split","trim","start","drawSVG","container","getDisplaySymbol","dispSymbols","Start","diagram","End","Operation","InputOutput","Input","Output","Subroutine","Condition","Parallel","Error","clean","constructChart","prevDisp","prev","dispSymb","startWith","pathOk","yes","no","path1","path2","path3","then","prevBreak","i0","i0len","line0","replace","substr","currentLine","parts","match","entries","entry","sub","join","txtAndState","pop","ann","flowSymbols","iS","lenS","symbVal","realSymb","direction","condOpt","yes_annotation","no_annotation","path1_annotation","path2_annotation","path3_annotation","nextSymb","lineStyleSymbols","iSS","lenSS","curSymb","nextSymbol","JSON","textMargin","yes_direction","direction_yes","no_direction","direction_no","startX","startY","yes_symbol","no_symbol","bottom_symbol","right_symbol","left_symbol","rect","path1_direction","path2_direction","path3_direction","direction_next","direction_path1","direction_path2","direction_path3","path1_symbol","path2_symbol","path3_symbol","top_symbol","topPoint","Raphael","handle","flowChart","maxHeight","maxY","minX","minY","leftX","x2","y2","scale","lineWidth","setSize","setViewBox","paperDom","canvas","parentNode","removeChild","line-width","line-length","text-margin","font-color","line-color","element-color","yes-text","no-text","class","end","condition","inputoutput","output","operation","subroutine","parallel","Array","searchElement","TypeError","t","n","arguments","Number","Infinity","floor","k","lastIndexOf","min","String","innerWrap","jQuery","$","paramFit","needle","haystack","isArray","includes","methods","init","each","$this","html","setFlowStateByParam","param","paramValue","newFlowState","nextSymbolKeys","property","hasOwnProperty","val","nski","nextSymbolKey","clearFlowState","fn","methodOrOptions","apply","slice","error"],"mappings":"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","file":"flowchart.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"Raphael\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"Raphael\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"Raphael\")) : factory(root[\"Raphael\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_18__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"Raphael\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"Raphael\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"Raphael\")) : factory(root[\"Raphael\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_18__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/*!******************!*\\\n  !*** ./index.js ***!\n  \\******************/\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(/*! ./src/flowchart.shim */ 9);\n\tvar parse = __webpack_require__(/*! ./src/flowchart.parse */ 4);\n\t__webpack_require__(/*! ./src/jquery-plugin */ 17);\n\t\n\tvar FlowChart = {\n\t\tparse: parse\n\t};\n\t\n\tif (typeof window !== 'undefined') {\n\t\twindow.flowchart = FlowChart;\n\t}\n\t\n\tmodule.exports = FlowChart;\n\n\n/***/ }),\n/* 1 */\n/*!**********************************!*\\\n  !*** ./src/flowchart.helpers.js ***!\n  \\**********************************/\n/***/ (function(module, exports) {\n\n\tfunction _defaults(options, defaultOptions) {\n\t  if (!options || typeof options === 'function') {\n\t    return defaultOptions;\n\t  }\n\t\n\t  var merged = {};\n\t  for (var attrname in defaultOptions) {\n\t    merged[attrname] = defaultOptions[attrname];\n\t  }\n\t\n\t  for (attrname in options) {\n\t    if (options[attrname]) {\n\t      if (typeof merged[attrname] === 'object') {\n\t        merged[attrname] = _defaults(merged[attrname], options[attrname]);\n\t      } else {\n\t        merged[attrname] = options[attrname];\n\t      }\n\t    }\n\t  }\n\t  return merged;\n\t}\n\t\n\tfunction _inherits(ctor, superCtor) {\n\t  if (typeof(Object.create) === 'function') {\n\t    // implementation from standard node.js 'util' module\n\t    ctor.super_ = superCtor;\n\t    ctor.prototype = Object.create(superCtor.prototype, {\n\t      constructor: {\n\t        value: ctor,\n\t        enumerable: false,\n\t        writable: true,\n\t        configurable: true\n\t      }\n\t    });\n\t  } else {\n\t    // old school shim for old browsers\n\t    ctor.super_ = superCtor;\n\t    var TempCtor = function () {};\n\t    TempCtor.prototype = superCtor.prototype;\n\t    ctor.prototype = new TempCtor();\n\t    ctor.prototype.constructor = ctor;\n\t  }\n\t}\n\t\n\t// move dependent functions to a container so that\n\t// they can be overriden easier in no jquery environment (node.js)\n\tmodule.exports = {\n\t  defaults: _defaults,\n\t  inherits: _inherits\n\t};\n\n\n/***/ }),\n/* 2 */\n/*!*********************************!*\\\n  !*** ./src/flowchart.symbol.js ***!\n  \\*********************************/\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar drawAPI = __webpack_require__(/*! ./flowchart.functions */ 3);\n\tvar drawLine = drawAPI.drawLine;\n\tvar checkLineIntersection = drawAPI.checkLineIntersection;\n\t\n\tfunction Symbol(chart, options, symbol) {\n\t  this.chart = chart;\n\t  this.group = this.chart.paper.set();\n\t  this.symbol = symbol;\n\t  this.connectedTo = [];\n\t  this.symbolType = options.symbolType;\n\t  this.flowstate = (options.flowstate || 'future');\n\t  this.lineStyle = (options.lineStyle || {});\n\t  this.key = (options.key || '');\n\t  this.leftLines = [];\n\t  this.rightLines = [];\n\t  this.topLines = [];\n\t  this.bottomLines = [];\n\t  this.params = options.params;\n\t\n\t  this.next_direction = options.next && options['direction_next'] ? options['direction_next'] : undefined;\n\t\n\t  this.text = this.chart.paper.text(0, 0, options.text);\n\t  //Raphael does not support the svg group tag so setting the text node id to the symbol node id plus t\n\t  if (options.key) { this.text.node.id = options.key + 't'; }\n\t  this.text.node.setAttribute('class', this.getAttr('class') + 't');\n\t\n\t  this.text.attr({\n\t    'text-anchor': 'start',\n\t    'x'          : this.getAttr('text-margin'),\n\t    'fill'       : this.getAttr('font-color'),\n\t    'font-size'  : this.getAttr('font-size')\n\t  });\n\t\n\t  var font  = this.getAttr('font');\n\t  var fontF = this.getAttr('font-family');\n\t  var fontW = this.getAttr('font-weight');\n\t\n\t  if (font) this.text.attr({ 'font': font });\n\t  if (fontF) this.text.attr({ 'font-family': fontF });\n\t  if (fontW) this.text.attr({ 'font-weight': fontW });\n\t\n\t  if (options.link) { this.text.attr('href', options.link); }\n\t  \n\t  //ndrqu Add click function with event and options params\n\t  if (options.function) { \n\t    this.text.attr({ 'cursor' : 'pointer' });\n\t\n\t    this.text.node.addEventListener(\"click\", function(evt) {\n\t        window[options.function](evt,options);\n\t    }, false);\n\t  }\n\t\n\t  if (options.target) { this.text.attr('target', options.target); }\n\t\n\t  var maxWidth = this.getAttr('maxWidth');\n\t  if (maxWidth) {\n\t    // using this approach: http://stackoverflow.com/a/3153457/22466\n\t    var words = options.text.split(' ');\n\t    var tempText = \"\";\n\t    for (var i=0, ii=words.length; i<ii; i++) {\n\t      var word = words[i];\n\t      this.text.attr(\"text\", tempText + \" \" + word);\n\t      if (this.text.getBBox().width > maxWidth) {\n\t        tempText += \"\\n\" + word;\n\t      } else {\n\t        tempText += \" \" + word;\n\t      }\n\t    }\n\t    this.text.attr(\"text\", tempText.substring(1));\n\t  }\n\t\n\t  this.group.push(this.text);\n\t\n\t  if (symbol) {\n\t    var tmpMargin = this.getAttr('text-margin');\n\t\n\t    symbol.attr({\n\t      'fill' : this.getAttr('fill'),\n\t      'stroke' : this.getAttr('element-color'),\n\t      'stroke-width' : this.getAttr('line-width'),\n\t      'width' : this.text.getBBox().width + 2 * tmpMargin,\n\t      'height' : this.text.getBBox().height + 2 * tmpMargin\n\t    });\n\t\n\t    symbol.node.setAttribute('class', this.getAttr('class'));\n\t    var roundness = this.getAttr('roundness');\n\t    if (!isNaN(roundness)) {\n\t      symbol.node.setAttribute('ry', roundness);\n\t      symbol.node.setAttribute('rx', roundness);\n\t    }\n\t\n\t    if (options.link) { symbol.attr('href', options.link); }\n\t    if (options.target) { symbol.attr('target', options.target); }\n\t\n\t    //ndrqu Add click function with event and options params\n\t    if (options.function) { \n\t        symbol.node.addEventListener(\"click\", function(evt) {\n\t          window[options.function](evt,options);\n\t        }, false);\n\t      symbol.attr({ 'cursor' : 'pointer' });\n\t    }\n\t    if (options.key) { symbol.node.id = options.key; }\n\t\n\t    this.group.push(symbol);\n\t    symbol.insertBefore(this.text);\n\t\n\t    this.text.attr({\n\t      'y': symbol.getBBox().height/2\n\t    });\n\t\n\t    this.initialize();\n\t  }\n\t\n\t}\n\t\n\t/* Gets the attribute based on Flowstate, Symbol-Name and default, first found wins */\n\tSymbol.prototype.getAttr = function(attName) {\n\t  if (!this.chart) {\n\t    return undefined;\n\t  }\n\t  var opt3 = (this.chart.options) ? this.chart.options[attName] : undefined;\n\t  var opt2 = (this.chart.options.symbols) ? this.chart.options.symbols[this.symbolType][attName] : undefined;\n\t  var opt1;\n\t  if (this.chart.options.flowstate && this.chart.options.flowstate[this.flowstate]) {\n\t    opt1 = this.chart.options.flowstate[this.flowstate][attName];\n\t  }\n\t  return (opt1 || opt2 || opt3);\n\t};\n\t\n\tSymbol.prototype.initialize = function() {\n\t  this.group.transform('t' + this.getAttr('line-width') + ',' + this.getAttr('line-width'));\n\t\n\t  this.width = this.group.getBBox().width;\n\t  this.height = this.group.getBBox().height;\n\t};\n\t\n\tSymbol.prototype.getCenter = function() {\n\t  return {x: this.getX() + this.width/2,\n\t          y: this.getY() + this.height/2};\n\t};\n\t\n\tSymbol.prototype.getX = function() {\n\t  return this.group.getBBox().x;\n\t};\n\t\n\tSymbol.prototype.getY = function() {\n\t  return this.group.getBBox().y;\n\t};\n\t\n\tSymbol.prototype.shiftX = function(x) {\n\t  this.group.transform('t' + (this.getX() + x) + ',' + this.getY());\n\t};\n\t\n\tSymbol.prototype.setX = function(x) {\n\t  this.group.transform('t' + x + ',' + this.getY());\n\t};\n\t\n\tSymbol.prototype.shiftY = function(y) {\n\t  this.group.transform('t' + this.getX() + ',' + (this.getY() + y));\n\t};\n\t\n\tSymbol.prototype.setY = function(y) {\n\t  this.group.transform('t' + this.getX() + ',' + y);\n\t};\n\t\n\tSymbol.prototype.getTop = function() {\n\t  var y = this.getY();\n\t  var x = this.getX() + this.width/2;\n\t  return {x: x, y: y};\n\t};\n\t\n\tSymbol.prototype.getBottom = function() {\n\t  var y = this.getY() + this.height;\n\t  var x = this.getX() + this.width/2;\n\t  return {x: x, y: y};\n\t};\n\t\n\tSymbol.prototype.getLeft = function() {\n\t  var y = this.getY() + this.group.getBBox().height/2;\n\t  var x = this.getX();\n\t  return {x: x, y: y};\n\t};\n\t\n\tSymbol.prototype.getRight = function() {\n\t  var y = this.getY() + this.group.getBBox().height/2;\n\t  var x = this.getX() + this.group.getBBox().width;\n\t  return {x: x, y: y};\n\t};\n\t\n\tSymbol.prototype.render = function() {\n\t  if (this.next) {\n\t\n\t    var self = this;\n\t    var lineLength = this.getAttr('line-length');\n\t\n\t    if (this.next_direction === 'right') {\n\t\n\t      var rightPoint = this.getRight();\n\t\n\t      if (!this.next.isPositioned) {\n\t        this.next.setY(rightPoint.y - this.next.height/2);\n\t        this.next.shiftX(this.group.getBBox().x + this.width + lineLength);\n\t\n\t        (function shift() {\n\t          var hasSymbolUnder = false;\n\t          var symb;\n\t          for (var i = 0, len = self.chart.symbols.length; i < len; i++) {\n\t            symb = self.chart.symbols[i];\n\t\n\t            var diff = Math.abs(symb.getCenter().x - self.next.getCenter().x);\n\t            if (symb.getCenter().y > self.next.getCenter().y && diff <= self.next.width/2) {\n\t              hasSymbolUnder = true;\n\t              break;\n\t            }\n\t          }\n\t\n\t          if (hasSymbolUnder) {\n\t            if (self.next.symbolType === 'end') return;\n\t            self.next.setX(symb.getX() + symb.width + lineLength);\n\t            shift();\n\t          }\n\t        })();\n\t\n\t        this.next.isPositioned = true;\n\t\n\t        this.next.render();\n\t      }\n\t    } else if (this.next_direction === 'left') {\n\t\n\t      var leftPoint = this.getLeft();\n\t\n\t      if (!this.next.isPositioned) {\n\t        this.next.setY(leftPoint.y - this.next.height/2);\n\t        this.next.shiftX(-(this.group.getBBox().x + this.width + lineLength));\n\t\n\t        (function shift() {\n\t          var hasSymbolUnder = false;\n\t          var symb;\n\t          for (var i = 0, len = self.chart.symbols.length; i < len; i++) {\n\t            symb = self.chart.symbols[i];\n\t\n\t            var diff = Math.abs(symb.getCenter().x - self.next.getCenter().x);\n\t            if (symb.getCenter().y > self.next.getCenter().y && diff <= self.next.width/2) {\n\t              hasSymbolUnder = true;\n\t              break;\n\t            }\n\t          }\n\t\n\t          if (hasSymbolUnder) {\n\t            if (self.next.symbolType === 'end') return;\n\t            self.next.setX(symb.getX() + symb.width + lineLength);\n\t            shift();\n\t          }\n\t        })();\n\t\n\t        this.next.isPositioned = true;\n\t\n\t        this.next.render();\n\t      }\n\t    } else {\n\t      var bottomPoint = this.getBottom();\n\t\n\t      if (!this.next.isPositioned) {\n\t        this.next.shiftY(this.getY() + this.height + lineLength);\n\t        this.next.setX(bottomPoint.x - this.next.width/2);\n\t        this.next.isPositioned = true;\n\t\n\t        this.next.render();\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\tSymbol.prototype.renderLines = function() {\n\t  if (this.next) {\n\t    if (this.next_direction) {\n\t      this.drawLineTo(this.next, this.getAttr('arrow-text') || '', this.next_direction);\n\t    } else {\n\t      this.drawLineTo(this.next, this.getAttr('arrow-text') || '');\n\t    }\n\t  }\n\t};\n\t\n\tSymbol.prototype.drawLineTo = function(symbol, text, origin) {\n\t  if (this.connectedTo.indexOf(symbol) < 0) {\n\t    this.connectedTo.push(symbol);\n\t  }\n\t\n\t  var x = this.getCenter().x,\n\t      y = this.getCenter().y,\n\t      right = this.getRight(),\n\t      bottom = this.getBottom(),\n\t      top = this.getTop(),\n\t      left = this.getLeft();\n\t\n\t  var symbolX = symbol.getCenter().x,\n\t      symbolY = symbol.getCenter().y,\n\t      symbolTop = symbol.getTop(),\n\t      symbolRight = symbol.getRight(),\n\t      symbolLeft = symbol.getLeft();\n\t\n\t  var isOnSameColumn = x === symbolX,\n\t      isOnSameLine = y === symbolY,\n\t      isUnder = y < symbolY,\n\t      isUpper = y > symbolY || this === symbol,\n\t      isLeft = x > symbolX,\n\t      isRight = x < symbolX;\n\t\n\t  var maxX = 0,\n\t      line,\n\t      yOffset,\n\t      lineLength = this.getAttr('line-length'),\n\t      lineWith = this.getAttr('line-width');\n\t\n\t  if ((!origin || origin === 'bottom') && isOnSameColumn && isUnder) {\n\t    if (symbol.topLines.length === 0 && this.bottomLines.length === 0) {\n\t      line = drawLine(this.chart, bottom, symbolTop, text);\n\t    } else {\n\t      yOffset = Math.max(symbol.topLines.length, this.bottomLines.length) * 10;\n\t      line = drawLine(this.chart, bottom, [\n\t        {x: symbolTop.x, y: symbolTop.y - yOffset},\n\t        {x: symbolTop.x, y: symbolTop.y}\n\t      ], text);\n\t    }\n\t    this.bottomLines.push(line);\n\t    symbol.topLines.push(line);\n\t    this.bottomStart = true;\n\t    symbol.topEnd = true;\n\t    maxX = bottom.x;\n\t  } else if ((!origin || origin === 'right') && isOnSameLine && isRight) {\n\t    if (symbol.leftLines.length === 0 && this.rightLines.length === 0) {\n\t      line = drawLine(this.chart, right, symbolLeft, text);\n\t    } else {\n\t      yOffset = Math.max(symbol.leftLines.length, this.rightLines.length) * 10;\n\t      line = drawLine(this.chart, right, [\n\t        {x: right.x, y: right.y - yOffset},\n\t        {x: right.x, y: symbolLeft.y - yOffset},\n\t        {x: symbolLeft.x, y: symbolLeft.y - yOffset},\n\t        {x: symbolLeft.x, y: symbolLeft.y}\n\t      ], text);\n\t    }\n\t    this.rightLines.push(line);\n\t    symbol.leftLines.push(line);\n\t    this.rightStart = true;\n\t    symbol.leftEnd = true;\n\t    maxX = symbolLeft.x;\n\t  } else if ((!origin || origin === 'left') && isOnSameLine && isLeft) {\n\t    if (symbol.rightLines.length === 0 && this.leftLines.length === 0) {\n\t      line = drawLine(this.chart, left, symbolRight, text);\n\t    } else {\n\t      yOffset = Math.max(symbol.rightLines.length, this.leftLines.length) * 10;\n\t      line = drawLine(this.chart, right, [\n\t        {x: right.x, y: right.y - yOffset},\n\t        {x: right.x, y: symbolRight.y - yOffset},\n\t        {x: symbolRight.x, y: symbolRight.y - yOffset},\n\t        {x: symbolRight.x, y: symbolRight.y}\n\t      ], text);\n\t    }\n\t    this.leftLines.push(line);\n\t    symbol.rightLines.push(line);\n\t    this.leftStart = true;\n\t    symbol.rightEnd = true;\n\t    maxX = symbolRight.x;\n\t  } else if ((!origin || origin === 'right') && isOnSameColumn && isUpper) {\n\t    yOffset = Math.max(symbol.topLines.length, this.rightLines.length) * 10;\n\t    line = drawLine(this.chart, right, [\n\t      {x: right.x + lineLength/2, y: right.y - yOffset},\n\t      {x: right.x + lineLength/2, y: symbolTop.y - lineLength/2 - yOffset},\n\t      {x: symbolTop.x, y: symbolTop.y - lineLength/2 - yOffset},\n\t      {x: symbolTop.x, y: symbolTop.y}\n\t    ], text);\n\t    this.rightLines.push(line);\n\t    symbol.topLines.push(line);\n\t    this.rightStart = true;\n\t    symbol.topEnd = true;\n\t    maxX = right.x + lineLength/2;\n\t  } else if ((!origin || origin === 'right') && isOnSameColumn && isUnder) {\n\t    yOffset = Math.max(symbol.topLines.length, this.rightLines.length) * 10;\n\t    line = drawLine(this.chart, right, [\n\t      {x: right.x + lineLength/2, y: right.y - yOffset},\n\t      {x: right.x + lineLength/2, y: symbolTop.y - lineLength/2 - yOffset},\n\t      {x: symbolTop.x, y: symbolTop.y - lineLength/2 - yOffset},\n\t      {x: symbolTop.x, y: symbolTop.y}\n\t    ], text);\n\t    this.rightLines.push(line);\n\t    symbol.topLines.push(line);\n\t    this.rightStart = true;\n\t    symbol.topEnd = true;\n\t    maxX = right.x + lineLength/2;\n\t  } else if ((!origin || origin === 'bottom') && isLeft) {\n\t    yOffset = Math.max(symbol.topLines.length, this.bottomLines.length) * 10;\n\t    if (this.leftEnd && isUpper) {\n\t      line = drawLine(this.chart, bottom, [\n\t        {x: bottom.x, y: bottom.y + lineLength/2 - yOffset},\n\t        {x: bottom.x + (bottom.x - symbolTop.x)/2, y: bottom.y + lineLength/2 - yOffset},\n\t        {x: bottom.x + (bottom.x - symbolTop.x)/2, y: symbolTop.y - lineLength/2 - yOffset},\n\t        {x: symbolTop.x, y: symbolTop.y - lineLength/2 - yOffset},\n\t        {x: symbolTop.x, y: symbolTop.y}\n\t      ], text);\n\t    } else {\n\t      line = drawLine(this.chart, bottom, [\n\t        {x: bottom.x, y: symbolTop.y - lineLength/2 - yOffset},\n\t        {x: symbolTop.x, y: symbolTop.y - lineLength/2 - yOffset},\n\t        {x: symbolTop.x, y: symbolTop.y}\n\t      ], text);\n\t    }\n\t    this.bottomLines.push(line);\n\t    symbol.topLines.push(line);\n\t    this.bottomStart = true;\n\t    symbol.topEnd = true;\n\t    maxX = bottom.x + (bottom.x - symbolTop.x)/2;\n\t  } else if ((!origin || origin === 'bottom') && isRight && isUnder) {\n\t    yOffset = Math.max(symbol.topLines.length, this.bottomLines.length) * 10;\n\t    line = drawLine(this.chart, bottom, [\n\t      {x: bottom.x, y: symbolTop.y - lineLength/2 - yOffset},\n\t      {x: symbolTop.x, y: symbolTop.y - lineLength/2 - yOffset},\n\t      {x: symbolTop.x, y: symbolTop.y}\n\t    ], text);\n\t    this.bottomLines.push(line);\n\t    symbol.topLines.push(line);\n\t    this.bottomStart = true;\n\t    symbol.topEnd = true;\n\t    maxX = bottom.x;\n\t    if (symbolTop.x > maxX) maxX = symbolTop.x;\n\t  } else if ((!origin || origin === 'bottom') && isRight) {\n\t    yOffset = Math.max(symbol.topLines.length, this.bottomLines.length) * 10;\n\t    line = drawLine(this.chart, bottom, [\n\t      {x: bottom.x, y: bottom.y + lineLength/2 - yOffset},\n\t      {x: bottom.x + (bottom.x - symbolTop.x)/2, y: bottom.y + lineLength/2 - yOffset},\n\t      {x: bottom.x + (bottom.x - symbolTop.x)/2, y: symbolTop.y - lineLength/2 - yOffset},\n\t      {x: symbolTop.x, y: symbolTop.y - lineLength/2 - yOffset},\n\t      {x: symbolTop.x, y: symbolTop.y}\n\t    ], text);\n\t    this.bottomLines.push(line);\n\t    symbol.topLines.push(line);\n\t    this.bottomStart = true;\n\t    symbol.topEnd = true;\n\t    maxX = bottom.x + (bottom.x - symbolTop.x)/2;\n\t  } else if ((origin && origin === 'right') && isLeft) {\n\t    yOffset = Math.max(symbol.topLines.length, this.rightLines.length) * 10;\n\t    line = drawLine(this.chart, right, [\n\t      {x: right.x + lineLength/2, y: right.y},\n\t      {x: right.x + lineLength/2, y: symbolTop.y - lineLength/2 - yOffset},\n\t      {x: symbolTop.x, y: symbolTop.y - lineLength/2 - yOffset},\n\t      {x: symbolTop.x, y: symbolTop.y}\n\t    ], text);\n\t    this.rightLines.push(line);\n\t    symbol.topLines.push(line);\n\t    this.rightStart = true;\n\t    symbol.topEnd = true;\n\t    maxX = right.x + lineLength/2;\n\t  } else if ((origin && origin === 'right') && isRight) {\n\t    yOffset = Math.max(symbol.topLines.length, this.rightLines.length) * 10;\n\t    line = drawLine(this.chart, right, [\n\t      {x: symbolTop.x, y: right.y - yOffset},\n\t      {x: symbolTop.x, y: symbolTop.y - yOffset}\n\t    ], text);\n\t    this.rightLines.push(line);\n\t    symbol.topLines.push(line);\n\t    this.rightStart = true;\n\t    symbol.topEnd = true;\n\t    maxX = right.x + lineLength/2;\n\t  } else if ((origin && origin === 'bottom') && isOnSameColumn && isUpper) {\n\t    yOffset = Math.max(symbol.topLines.length, this.bottomLines.length) * 10;\n\t    line = drawLine(this.chart, bottom, [\n\t      {x: bottom.x, y: bottom.y + lineLength/2 - yOffset},\n\t      {x: right.x + lineLength/2, y: bottom.y + lineLength/2 - yOffset},\n\t      {x: right.x + lineLength/2, y: symbolTop.y - lineLength/2 - yOffset},\n\t      {x: symbolTop.x, y: symbolTop.y - lineLength/2 - yOffset},\n\t      {x: symbolTop.x, y: symbolTop.y}\n\t    ], text);\n\t    this.bottomLines.push(line);\n\t    symbol.topLines.push(line);\n\t    this.bottomStart = true;\n\t    symbol.topEnd = true;\n\t    maxX = bottom.x + lineLength/2;\n\t  } else if ((origin === 'left') && isOnSameColumn && isUpper) {\n\t    var diffX = left.x - lineLength/2;\n\t    if (symbolLeft.x < left.x) {\n\t      diffX = symbolLeft.x - lineLength/2;\n\t    }\n\t    yOffset = Math.max(symbol.topLines.length, this.leftLines.length) * 10;\n\t    line = drawLine(this.chart, left, [\n\t      {x: diffX, y: left.y - yOffset},\n\t      {x: diffX, y: symbolTop.y - lineLength/2 - yOffset},\n\t      {x: symbolTop.x, y: symbolTop.y - lineLength/2 - yOffset},\n\t      {x: symbolTop.x, y: symbolTop.y}\n\t    ], text);\n\t    this.leftLines.push(line);\n\t    symbol.topLines.push(line);\n\t    this.leftStart = true;\n\t    symbol.topEnd = true;\n\t    maxX = left.x;\n\t  } else if ((origin === 'left')) {\n\t    yOffset = Math.max(symbol.topLines.length, this.leftLines.length) * 10;\n\t    line = drawLine(this.chart, left, [\n\t      {x: symbolTop.x + (left.x - symbolTop.x)/2, y: left.y},\n\t      {x: symbolTop.x + (left.x - symbolTop.x)/2, y: symbolTop.y - lineLength/2 - yOffset},\n\t      {x: symbolTop.x, y: symbolTop.y - lineLength/2 - yOffset},\n\t      {x: symbolTop.x, y: symbolTop.y}\n\t    ], text);\n\t    this.leftLines.push(line);\n\t    symbol.topLines.push(line);\n\t    this.leftStart = true;\n\t    symbol.topEnd = true;\n\t    maxX = left.x;\n\t  } else if ((origin === 'top')) {\n\t    yOffset = Math.max(symbol.topLines.length, this.topLines.length) * 10;\n\t    line = drawLine(this.chart, top, [\n\t      {x: top.x, y: symbolTop.y - lineLength/2 - yOffset},\n\t      {x: symbolTop.x, y: symbolTop.y - lineLength/2 - yOffset},\n\t      {x: symbolTop.x, y: symbolTop.y}\n\t    ], text);\n\t    this.topLines.push(line);\n\t    symbol.topLines.push(line);\n\t    this.topStart = true;\n\t    symbol.topEnd = true;\n\t    maxX = top.x;\n\t  }\n\t\n\t  //update line style\n\t  if (this.lineStyle[symbol.key] && line){\n\t    line.attr(this.lineStyle[symbol.key]);\n\t  }\n\t\n\t  if (line) {\n\t    for (var l = 0, llen = this.chart.lines.length; l < llen; l++) {\n\t      var otherLine = this.chart.lines[l];\n\t\n\t      var ePath = otherLine.attr('path'),\n\t          lPath = line.attr('path');\n\t\n\t      for (var iP = 0, lenP = ePath.length - 1; iP < lenP; iP++) {\n\t        var newPath = [];\n\t        newPath.push(['M', ePath[iP][1], ePath[iP][2]]);\n\t        newPath.push(['L', ePath[iP + 1][1], ePath[iP + 1][2]]);\n\t\n\t        var line1_from_x = newPath[0][1];\n\t        var line1_from_y = newPath[0][2];\n\t        var line1_to_x = newPath[1][1];\n\t        var line1_to_y = newPath[1][2];\n\t\n\t        for (var lP = 0, lenlP = lPath.length - 1; lP < lenlP; lP++) {\n\t          var newLinePath = [];\n\t          newLinePath.push(['M', lPath[lP][1], lPath[lP][2]]);\n\t          newLinePath.push(['L', lPath[lP + 1][1], lPath[lP + 1][2]]);\n\t\n\t          var line2_from_x = newLinePath[0][1];\n\t          var line2_from_y = newLinePath[0][2];\n\t          var line2_to_x = newLinePath[1][1];\n\t          var line2_to_y = newLinePath[1][2];\n\t\n\t          var res = checkLineIntersection(line1_from_x, line1_from_y, line1_to_x, line1_to_y, line2_from_x, line2_from_y, line2_to_x, line2_to_y);\n\t          if (res.onLine1 && res.onLine2) {\n\t\n\t            var newSegment;\n\t            if (line2_from_y === line2_to_y) {\n\t              if (line2_from_x > line2_to_x) {\n\t                newSegment = ['L', res.x + lineWith * 2,  line2_from_y];\n\t                lPath.splice(lP + 1, 0, newSegment);\n\t                newSegment = ['C', res.x + lineWith * 2,  line2_from_y, res.x, line2_from_y - lineWith * 4, res.x - lineWith * 2, line2_from_y];\n\t                lPath.splice(lP + 2, 0, newSegment);\n\t                line.attr('path', lPath);\n\t              } else {\n\t                newSegment = ['L', res.x - lineWith * 2,  line2_from_y];\n\t                lPath.splice(lP + 1, 0, newSegment);\n\t                newSegment = ['C', res.x - lineWith * 2,  line2_from_y, res.x, line2_from_y - lineWith * 4, res.x + lineWith * 2, line2_from_y];\n\t                lPath.splice(lP + 2, 0, newSegment);\n\t                line.attr('path', lPath);\n\t              }\n\t            } else {\n\t              if (line2_from_y > line2_to_y) {\n\t                newSegment = ['L', line2_from_x, res.y + lineWith * 2];\n\t                lPath.splice(lP + 1, 0, newSegment);\n\t                newSegment = ['C', line2_from_x, res.y + lineWith * 2, line2_from_x + lineWith * 4, res.y, line2_from_x, res.y - lineWith * 2];\n\t                lPath.splice(lP + 2, 0, newSegment);\n\t                line.attr('path', lPath);\n\t              } else {\n\t                newSegment = ['L', line2_from_x, res.y - lineWith * 2];\n\t                lPath.splice(lP + 1, 0, newSegment);\n\t                newSegment = ['C', line2_from_x, res.y - lineWith * 2, line2_from_x + lineWith * 4, res.y, line2_from_x, res.y + lineWith * 2];\n\t                lPath.splice(lP + 2, 0, newSegment);\n\t                line.attr('path', lPath);\n\t              }\n\t            }\n\t\n\t            lP += 2;\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    this.chart.lines.push(line);\n\t    if (this.chart.minXFromSymbols === undefined || this.chart.minXFromSymbols > left.x) {\n\t      this.chart.minXFromSymbols = left.x;\n\t    }\n\t  }\n\t\n\t  if (!this.chart.maxXFromLine || (this.chart.maxXFromLine && maxX > this.chart.maxXFromLine)) {\n\t    this.chart.maxXFromLine = maxX;\n\t  }\n\t};\n\t\n\tmodule.exports = Symbol;\n\n\n/***/ }),\n/* 3 */\n/*!************************************!*\\\n  !*** ./src/flowchart.functions.js ***!\n  \\************************************/\n/***/ (function(module, exports) {\n\n\tfunction drawPath(chart, location, points) {\n\t  var i, len;\n\t  var path = 'M{0},{1}';\n\t  for (i = 2, len = 2 * points.length + 2; i < len; i+=2) {\n\t    path += ' L{' + i + '},{' + (i + 1) + '}';\n\t  }\n\t  var pathValues = [location.x, location.y];\n\t  for (i = 0, len = points.length; i < len; i++) {\n\t    pathValues.push(points[i].x);\n\t    pathValues.push(points[i].y);\n\t  }\n\t  var symbol = chart.paper.path(path, pathValues);\n\t  symbol.attr('stroke', chart.options['element-color']);\n\t  symbol.attr('stroke-width', chart.options['line-width']);\n\t\n\t  var font = chart.options.font;\n\t  var fontF = chart.options['font-family'];\n\t  var fontW = chart.options['font-weight'];\n\t\n\t  if (font) symbol.attr({ 'font': font });\n\t  if (fontF) symbol.attr({ 'font-family': fontF });\n\t  if (fontW) symbol.attr({ 'font-weight': fontW });\n\t\n\t  return symbol;\n\t}\n\t\n\tfunction drawLine(chart, from, to, text) {\n\t  var i, len;\n\t\n\t  if (Object.prototype.toString.call(to) !== '[object Array]') {\n\t    to = [to];\n\t  }\n\t\n\t  var path = 'M{0},{1}';\n\t  for (i = 2, len = 2 * to.length + 2; i < len; i+=2) {\n\t    path += ' L{' + i + '},{' + (i + 1) + '}';\n\t  }\n\t  var pathValues = [from.x, from.y];\n\t  for (i = 0, len = to.length; i < len; i++) {\n\t    pathValues.push(to[i].x);\n\t    pathValues.push(to[i].y);\n\t  }\n\t\n\t  var line = chart.paper.path(path, pathValues);\n\t  line.attr({\n\t    stroke: chart.options['line-color'],\n\t    'stroke-width': chart.options['line-width'],\n\t    'arrow-end': chart.options['arrow-end']\n\t  });\n\t\n\t  var font = chart.options.font;\n\t  var fontF = chart.options['font-family'];\n\t  var fontW = chart.options['font-weight'];\n\t\n\t  if (font) line.attr({ 'font': font });\n\t  if (fontF) line.attr({ 'font-family': fontF });\n\t  if (fontW) line.attr({ 'font-weight': fontW });\n\t\n\t  if (text) {\n\t\n\t    var centerText = false;\n\t\n\t    var textPath = chart.paper.text(0, 0, text);\n\t    var textAnchor = 'start';\n\t\n\t    var isHorizontal = false;\n\t    var firstTo = to[0];\n\t\n\t    if (from.y === firstTo.y) {\n\t      isHorizontal = true;\n\t    }\n\t\n\t    var x = 0,\n\t        y = 0;\n\t\n\t    if (centerText) {\n\t      if (from.x > firstTo.x) {\n\t        x = from.x - (from.x - firstTo.x)/2;\n\t      } else {\n\t        x = firstTo.x - (firstTo.x - from.x)/2;\n\t      }\n\t\n\t      if (from.y > firstTo.y) {\n\t        y = from.y - (from.y - firstTo.y)/2;\n\t      } else {\n\t        y = firstTo.y - (firstTo.y - from.y)/2;\n\t      }\n\t\n\t      if (isHorizontal) {\n\t        x -= textPath.getBBox().width/2;\n\t        y -= chart.options['text-margin'];\n\t      } else {\n\t        x += chart.options['text-margin'];\n\t        y -= textPath.getBBox().height/2;\n\t      }\n\t    } else {\n\t      x = from.x;\n\t      y = from.y;\n\t\n\t      if (isHorizontal) {\n\t        if (from.x > firstTo.x) {\n\t          x -= chart.options['text-margin']/2;\n\t          textAnchor = 'end';\n\t        } else {\n\t          x += chart.options['text-margin']/2;\n\t        }\n\t        y -= chart.options['text-margin'];\n\t      } else {\n\t        x += chart.options['text-margin']/2;\n\t        y += chart.options['text-margin'];\n\t        if (from.y > firstTo.y) {\n\t          y -= chart.options['text-margin']*2;\n\t        }\n\t      }\n\t    }\n\t\n\t    textPath.attr({\n\t      'text-anchor': textAnchor,\n\t      'font-size': chart.options['font-size'],\n\t      'fill': chart.options['font-color'],\n\t      x: x,\n\t      y: y\n\t    });\n\t\n\t    if (font) textPath.attr({ 'font': font });\n\t    if (fontF) textPath.attr({ 'font-family': fontF });\n\t    if (fontW) textPath.attr({ 'font-weight': fontW });\n\t  }\n\t\n\t  return line;\n\t}\n\t\n\tfunction checkLineIntersection(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {\n\t  // if the lines intersect, the result contains the x and y of the intersection (treating the lines as infinite) and booleans for whether line segment 1 or line segment 2 contain the point\n\t  var denominator, a, b, numerator1, numerator2, result = {\n\t    x: null,\n\t    y: null,\n\t    onLine1: false,\n\t    onLine2: false\n\t  };\n\t  denominator = ((line2EndY - line2StartY) * (line1EndX - line1StartX)) - ((line2EndX - line2StartX) * (line1EndY - line1StartY));\n\t  if (denominator === 0) {\n\t    return result;\n\t  }\n\t  a = line1StartY - line2StartY;\n\t  b = line1StartX - line2StartX;\n\t  numerator1 = ((line2EndX - line2StartX) * a) - ((line2EndY - line2StartY) * b);\n\t  numerator2 = ((line1EndX - line1StartX) * a) - ((line1EndY - line1StartY) * b);\n\t  a = numerator1 / denominator;\n\t  b = numerator2 / denominator;\n\t\n\t  // if we cast these lines infinitely in both directions, they intersect here:\n\t  result.x = line1StartX + (a * (line1EndX - line1StartX));\n\t  result.y = line1StartY + (a * (line1EndY - line1StartY));\n\t  /*\n\t  // it is worth noting that this should be the same as:\n\t  x = line2StartX + (b * (line2EndX - line2StartX));\n\t  y = line2StartX + (b * (line2EndY - line2StartY));\n\t  */\n\t  // if line1 is a segment and line2 is infinite, they intersect if:\n\t  if (a > 0 && a < 1) {\n\t    result.onLine1 = true;\n\t  }\n\t  // if line2 is a segment and line1 is infinite, they intersect if:\n\t  if (b > 0 && b < 1) {\n\t    result.onLine2 = true;\n\t  }\n\t  // if line1 and line2 are segments, they intersect if both of the above are true\n\t  return result;\n\t}\n\t\n\tmodule.exports = {\n\t\tdrawPath: drawPath,\n\t\tdrawLine: drawLine,\n\t\tcheckLineIntersection: checkLineIntersection\n\t};\n\n\n/***/ }),\n/* 4 */\n/*!********************************!*\\\n  !*** ./src/flowchart.parse.js ***!\n  \\********************************/\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar FlowChart = __webpack_require__(/*! ./flowchart.chart */ 7);\n\tvar Start = __webpack_require__(/*! ./flowchart.symbol.start */ 15);\n\tvar End = __webpack_require__(/*! ./flowchart.symbol.end */ 10);\n\tvar Operation = __webpack_require__(/*! ./flowchart.symbol.operation */ 13);\n\tvar InputOutput = __webpack_require__(/*! ./flowchart.symbol.inputoutput */ 12);\n\tvar Input = __webpack_require__(/*! ./flowchart.symbol.input */ 11); //tds\n\tvar Output = __webpack_require__(/*! ./flowchart.symbol.output */ 14); //tds\n\tvar Subroutine = __webpack_require__(/*! ./flowchart.symbol.subroutine */ 16);\n\tvar Condition = __webpack_require__(/*! ./flowchart.symbol.condition */ 5);\n\tvar Parallel = __webpack_require__(/*! ./flowchart.symbol.parallel */ 6);\n\t\n\t\n\tfunction parse(input) {\n\t  input = input || '';\n\t  input = input.trim();\n\t\n\t  var chart = {\n\t    symbols: {},\n\t    start: null,\n\t    drawSVG: function(container, options) {\n\t      var self = this;\n\t\n\t      if (this.diagram) {\n\t        this.diagram.clean();\n\t      }\n\t\n\t      var diagram = new FlowChart(container, options);\n\t      this.diagram = diagram;\n\t      var dispSymbols = {};\n\t\n\t      function getDisplaySymbol(s) {\n\t        if (dispSymbols[s.key]) {\n\t          return dispSymbols[s.key];\n\t        }\n\t\n\t        switch (s.symbolType) {\n\t          case 'start':\n\t            dispSymbols[s.key] = new Start(diagram, s);\n\t            break;\n\t          case 'end':\n\t            dispSymbols[s.key] = new End(diagram, s);\n\t            break;\n\t          case 'operation':\n\t            dispSymbols[s.key] = new Operation(diagram, s);\n\t            break;\n\t          case 'inputoutput':\n\t            dispSymbols[s.key] = new InputOutput(diagram, s);\n\t            break;\n\t          case 'input':\n\t            dispSymbols[s.key] = new Input(diagram, s); //tds\n\t            break;         \n\t          case 'output':\n\t            dispSymbols[s.key] = new Output(diagram, s); //tds\n\t            break;          \n\t          case 'subroutine':\n\t            dispSymbols[s.key] = new Subroutine(diagram, s);\n\t            break;\n\t          case 'condition':\n\t            dispSymbols[s.key] = new Condition(diagram, s);\n\t            break;\n\t          case 'parallel':\n\t            dispSymbols[s.key] = new Parallel(diagram, s);\n\t            break;\n\t          default:\n\t            return new Error('Wrong symbol type!');\n\t        }\n\t\n\t        return dispSymbols[s.key];\n\t      }\n\t\n\t      (function constructChart(s, prevDisp, prev) {\n\t        var dispSymb = getDisplaySymbol(s);\n\t\n\t        if (self.start === s) {\n\t          diagram.startWith(dispSymb);\n\t        } else if (prevDisp && prev && !prevDisp.pathOk) {\n\t          if (prevDisp instanceof(Condition)) {\n\t            if (prev.yes === s) {\n\t              prevDisp.yes(dispSymb);\n\t            }\n\t            if (prev.no === s) {\n\t              prevDisp.no(dispSymb);\n\t            }\n\t          } else if (prevDisp instanceof(Parallel)) {\n\t            if (prev.path1 === s) {\n\t              prevDisp.path1(dispSymb);\n\t            }\n\t            if (prev.path2 === s) {\n\t              prevDisp.path2(dispSymb);\n\t            }\n\t            if (prev.path3 === s) {\n\t              prevDisp.path3(dispSymb);\n\t            }\n\t          } else {\n\t            prevDisp.then(dispSymb);\n\t          }\n\t        }\n\t\n\t        if (dispSymb.pathOk) {\n\t          return dispSymb;\n\t        }\n\t\n\t        if (dispSymb instanceof(Condition)) {\n\t          if (s.yes) {\n\t            constructChart(s.yes, dispSymb, s);\n\t          }\n\t          if (s.no) {\n\t            constructChart(s.no, dispSymb, s);\n\t          }\n\t        } else if (dispSymb instanceof(Parallel)) {\n\t          if (s.path1) {\n\t            constructChart(s.path1, dispSymb, s);\n\t          }\n\t          if (s.path2) {\n\t            constructChart(s.path2, dispSymb, s);\n\t          }\n\t          if (s.path3) {\n\t            constructChart(s.path3, dispSymb, s);\n\t          }\n\t        } else if (s.next) {\n\t          constructChart(s.next, dispSymb, s);\n\t        }\n\t\n\t        return dispSymb;\n\t      })(this.start);\n\t\n\t      diagram.render();\n\t    },\n\t    clean: function() {\n\t      this.diagram.clean();\n\t    },\n\t    options: function() {\n\t      return this.diagram.options;\n\t    }\n\t  };\n\t\n\t  var lines = [];\n\t  var prevBreak = 0;\n\t  for (var i0 = 1, i0len = input.length; i0 < i0len; i0++) {\n\t    if(input[i0] === '\\n' && input[i0 - 1] !== '\\\\') {\n\t      var line0 = input.substring(prevBreak, i0);\n\t      prevBreak = i0 + 1;\n\t      lines.push(line0.replace(/\\\\\\n/g, '\\n'));\n\t    }\n\t  }\n\t\n\t  if (prevBreak < input.length) {\n\t    lines.push(input.substr(prevBreak));\n\t  }\n\t\n\t  for (var l = 1, len = lines.length; l < len;) {\n\t    var currentLine = lines[l];\n\t\n\t    if (currentLine.indexOf('->') < 0 && currentLine.indexOf('=>') < 0 && currentLine.indexOf('@>') < 0) {\n\t      lines[l - 1] += '\\n' + currentLine;\n\t      lines.splice(l, 1);\n\t      len--;\n\t    } else {\n\t      l++;\n\t    }\n\t  }\n\t\n\t  function getStyle(s){\n\t    var startIndex = s.indexOf('(') + 1;\n\t    var endIndex = s.indexOf(')');\n\t    if (startIndex >= 0 && endIndex >= 0) {\n\t      return s.substring(startIndex,endIndex);\n\t    }\n\t    return '{}';\n\t  }\n\t\n\t  function getSymbValue(s){\n\t    var startIndex = s.indexOf('(') + 1;\n\t    var endIndex = s.indexOf(')');\n\t    if (startIndex >= 0 && endIndex >= 0) {\n\t      return s.substring(startIndex,endIndex);\n\t    }\n\t    return '';\n\t  }\n\t\n\t  function getSymbol(s) {\n\t    var startIndex = s.indexOf('(') + 1;\n\t    var endIndex = s.indexOf(')');\n\t    if (startIndex >= 0 && endIndex >= 0) {\n\t      return chart.symbols[s.substring(0, startIndex - 1)];\n\t    }\n\t    return chart.symbols[s];\n\t  }\n\t\n\t  function getNextPath(s) {\n\t    var next = 'next';\n\t    var startIndex = s.indexOf('(') + 1;\n\t    var endIndex = s.indexOf(')');\n\t    if (startIndex >= 0 && endIndex >= 0) {\n\t      next = flowSymb.substring(startIndex, endIndex);\n\t      if (next.indexOf(',') < 0) {\n\t        if (next !== 'yes' && next !== 'no') {\n\t          next = 'next, ' + next;\n\t        }\n\t      }\n\t    }\n\t    return next;\n\t  }\n\t  \n\t  function getAnnotation(s) {\n\t\tvar startIndex = s.indexOf(\"(\") + 1, endIndex = s.indexOf(\")\");\n\t\tvar tmp = s.substring(startIndex, endIndex);\n\t\tif(tmp.indexOf(\",\") > 0) { tmp = tmp.substring(0, tmp.indexOf(\",\")); }\n\t\tvar tmp_split = tmp.split(\"@\");\n\t\tif(tmp_split.length > 1)\n\t\t\treturn startIndex >= 0 && endIndex >= 0 ? tmp_split[1] : \"\";\n\t  }\n\t\n\t  while (lines.length > 0) {\n\t    var line = lines.splice(0, 1)[0].trim();\n\t\n\t    if (line.indexOf('=>') >= 0) {\n\t      // definition\n\t      var parts = line.split('=>');\n\t      var symbol = {\n\t        key: parts[0].replace(/\\(.*\\)/, ''),\n\t        symbolType: parts[1],\n\t        text: null,\n\t        link: null,\n\t        target: null,\n\t        flowstate: null,\n\t        function: null,\n\t        lineStyle: {},\n\t        params: {}\n\t      };\n\t\n\t      //parse parameters\n\t      var params = parts[0].match(/\\((.*)\\)/);\n\t      if (params && params.length > 1){\n\t        var entries = params[1].split(',');\n\t        for(var i = 0; i < entries.length; i++) {\n\t          var entry = entries[i].split('=');\n\t          if (entry.length == 2) {\n\t            symbol.params[entry[0]] = entry[1];\n\t          }\n\t        }\n\t      }\n\t\n\t      var sub;\n\t\n\t      if (symbol.symbolType.indexOf(': ') >= 0) {\n\t        sub = symbol.symbolType.split(': ');\n\t        symbol.symbolType = sub.shift();\n\t        symbol.text = sub.join(': ');\n\t      }\n\t\n\t      if (symbol.text && symbol.text.indexOf(':$') >= 0) {\n\t        sub = symbol.text.split(':$');\n\t        symbol.text = sub.shift();\n\t        symbol.function = sub.join(':$');\n\t      } else if (symbol.symbolType.indexOf(':$') >= 0) {\n\t        sub = symbol.symbolType.split(':$');\n\t        symbol.symbolType = sub.shift();\n\t        symbol.function = sub.join(':$');\n\t      } else if (symbol.text && symbol.text.indexOf(':>') >= 0) {\n\t        sub = symbol.text.split(':>');\n\t        symbol.text = sub.shift();\n\t        symbol.link = sub.join(':>');\n\t      } else if (symbol.symbolType.indexOf(':>') >= 0) {\n\t        sub = symbol.symbolType.split(':>');\n\t        symbol.symbolType = sub.shift();\n\t        symbol.link = sub.join(':>');\n\t      }\n\t\n\t      if (symbol.symbolType.indexOf('\\n') >= 0) {\n\t        symbol.symbolType = symbol.symbolType.split('\\n')[0];\n\t      }\n\t\n\t      /* adding support for links */\n\t      if (symbol.link) {\n\t        var startIndex = symbol.link.indexOf('[') + 1;\n\t        var endIndex = symbol.link.indexOf(']');\n\t        if (startIndex >= 0 && endIndex >= 0) {\n\t          symbol.target = symbol.link.substring(startIndex, endIndex);\n\t          symbol.link = symbol.link.substring(0, startIndex - 1);\n\t        }\n\t      }\n\t      /* end of link support */\n\t\n\t      /* adding support for flowstates */\n\t      if (symbol.text) {\n\t        if (symbol.text.indexOf('|') >= 0) {\n\t          var txtAndState = symbol.text.split('|');\n\t          symbol.flowstate = txtAndState.pop().trim();\n\t          symbol.text = txtAndState.join('|');\n\t        }\n\t      }\n\t      /* end of flowstate support */\n\t\n\t      chart.symbols[symbol.key] = symbol;\n\t\n\t    } else if (line.indexOf('->') >= 0) {\n\t      var ann = getAnnotation(line);\n\t      if (ann) {\n\t        line = line.replace('@' + ann, ''); \n\t      }\n\t      // flow\n\t      var flowSymbols = line.split('->');\n\t      for (var iS = 0, lenS = flowSymbols.length; iS < lenS; iS++) {\n\t        var flowSymb = flowSymbols[iS];\n\t        var symbVal = getSymbValue(flowSymb);\n\t\n\t        if (symbVal === 'true' || symbVal === 'false') {\n\t          // map true or false to yes or no respectively\n\t          flowSymb = flowSymb.replace('true', 'yes');\n\t          flowSymb = flowSymb.replace('false', 'no');\n\t        }\n\t        \n\t        var next = getNextPath(flowSymb);\n\t        var realSymb = getSymbol(flowSymb);\n\t\n\t        var direction = null;\n\t        if (next.indexOf(',') >= 0) {\n\t          var condOpt = next.split(',');\n\t          next = condOpt[0];\n\t          direction = condOpt[1].trim();\n\t        }\n\t\n\t        if (ann) {\n\t          if (realSymb.symbolType === 'condition') {\n\t            if (next === \"yes\" || next === \"true\") {\n\t              realSymb.yes_annotation = ann;\n\t            } else {\n\t              realSymb.no_annotation = ann;\n\t            }\n\t          } else if (realSymb.symbolType === 'parallel') {\n\t            if (next === 'path1') {\n\t              realSymb.path1_annotation = ann;\n\t            } else if (next === 'path2') {\n\t              realSymb.path2_annotation = ann;\n\t            } else if (next === 'path3') {\n\t              realSymb.path3_annotation = ann;\n\t            }\n\t          }\n\t          ann = null;\n\t        }\n\t\n\t        if (!chart.start) {\n\t          chart.start = realSymb;\n\t        }\n\t\n\t        if (iS + 1 < lenS) {\n\t          var nextSymb = flowSymbols[iS + 1];\n\t          realSymb[next] = getSymbol(nextSymb);\n\t          realSymb['direction_' + next] = direction;\n\t          direction = null;\n\t        }\n\t      }\n\t    } else if (line.indexOf('@>') >= 0) {\n\t\n\t      // line style\n\t      var lineStyleSymbols = line.split('@>');\n\t      for (var iSS = 0, lenSS = lineStyleSymbols.length; iSS < lenSS; iSS++) {\n\t        if ((iSS + 1) !== lenSS) {\n\t          var curSymb = getSymbol(lineStyleSymbols[iSS]);\n\t          var nextSymbol = getSymbol(lineStyleSymbols[iSS+1]);\n\t\n\t          curSymb['lineStyle'][nextSymbol.key] = JSON.parse(getStyle(lineStyleSymbols[iSS + 1]));\n\t        }\n\t      }\n\t    }\n\t\n\t  }\n\t  return chart;\n\t}\n\t\n\tmodule.exports = parse;\n\n\n/***/ }),\n/* 5 */\n/*!*******************************************!*\\\n  !*** ./src/flowchart.symbol.condition.js ***!\n  \\*******************************************/\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Symbol = __webpack_require__(/*! ./flowchart.symbol */ 2);\n\tvar inherits = __webpack_require__(/*! ./flowchart.helpers */ 1).inherits;\n\tvar drawAPI = __webpack_require__(/*! ./flowchart.functions */ 3);\n\tvar drawPath = drawAPI.drawPath;\n\t\n\tfunction Condition(chart, options) {\n\t  options = options || {};\n\t  Symbol.call(this, chart, options);\n\t  this.yes_annotation = options.yes_annotation;\n\t  this.no_annotation = options.no_annotation;\n\t  this.textMargin = this.getAttr('text-margin');\n\t  this.yes_direction = options.direction_yes;\n\t  this.no_direction = options.direction_no;\n\t  if (!this.no_direction && this.yes_direction === 'right') {\n\t    this.no_direction = 'bottom';\n\t  } else if (!this.yes_direction && this.no_direction === 'bottom') {\n\t    this.yes_direction = 'right'\n\t  }\n\t  this.yes_direction = this.yes_direction || 'bottom';\n\t  this.no_direction = this.no_direction || 'right';\n\t\n\t  this.text.attr({\n\t    x: this.textMargin * 2\n\t  });\n\t\n\t  var width = this.text.getBBox().width + 3 * this.textMargin;\n\t  width += width/2;\n\t  var height = this.text.getBBox().height + 2 * this.textMargin;\n\t  height += height/2;\n\t  height = Math.max(width * 0.5, height);\n\t  var startX = width/4;\n\t  var startY = height/4;\n\t\n\t  this.text.attr({\n\t    x: startX + this.textMargin/2\n\t  });\n\t\n\t  var start = {x: startX, y: startY};\n\t  var points = [\n\t    {x: startX - width/4, y: startY + height/4},\n\t    {x: startX - width/4 + width/2, y: startY + height/4 + height/2},\n\t    {x: startX - width/4 + width, y: startY + height/4},\n\t    {x: startX - width/4 + width/2, y: startY + height/4 - height/2},\n\t    {x: startX - width/4, y: startY + height/4}\n\t  ];\n\t\n\t  var symbol = drawPath(chart, start, points);\n\t\n\t  symbol.attr({\n\t    stroke: this.getAttr('element-color'),\n\t    'stroke-width': this.getAttr('line-width'),\n\t    fill: this.getAttr('fill')\n\t  });\n\t  if (options.link) { symbol.attr('href', options.link); }\n\t  if (options.target) { symbol.attr('target', options.target); }\n\t  if (options.key) { symbol.node.id = options.key; }\n\t  symbol.node.setAttribute('class', this.getAttr('class'));\n\t\n\t  this.text.attr({\n\t    y: symbol.getBBox().height/2\n\t  });\n\t\n\t  this.group.push(symbol);\n\t  symbol.insertBefore(this.text);\n\t  this.symbol = symbol\n\t\n\t  this.initialize();\n\t}\n\tinherits(Condition, Symbol);\n\t\n\tCondition.prototype.render = function() {\n\t  var self = this;\n\t  if (this.yes_direction) {\n\t    this[this.yes_direction + '_symbol'] = this.yes_symbol;\n\t  }\n\t\n\t  if (this.no_direction) {\n\t    this[this.no_direction + '_symbol'] = this.no_symbol;\n\t  }\n\t\n\t  var lineLength = this.getAttr('line-length');\n\t\n\t  if (this.bottom_symbol) {\n\t    var bottomPoint = this.getBottom();\n\t\n\t    if (!this.bottom_symbol.isPositioned) {\n\t      this.bottom_symbol.shiftY(this.getY() + this.height + lineLength);\n\t      this.bottom_symbol.setX(bottomPoint.x - this.bottom_symbol.width/2);\n\t      this.bottom_symbol.isPositioned = true;\n\t\n\t      this.bottom_symbol.render();\n\t    }\n\t  }\n\t\n\t  if (this.right_symbol) {\n\t    var rightPoint = this.getRight();\n\t\n\t    if (!this.right_symbol.isPositioned) {\n\t\n\t      this.right_symbol.setY(rightPoint.y - this.right_symbol.height/2);\n\t      this.right_symbol.shiftX(this.group.getBBox().x + this.width + lineLength);\n\t\n\t      (function shift() {\n\t        var hasSymbolUnder = false;\n\t        var symb;\n\t        for (var i = 0, len = self.chart.symbols.length; i < len; i++) {\n\t          symb = self.chart.symbols[i];\n\t\n\t          if (!self.params['align-next'] || self.params['align-next'] !== 'no') { \n\t            var diff = Math.abs(symb.getCenter().x - self.right_symbol.getCenter().x);\n\t            if (symb.getCenter().y > self.right_symbol.getCenter().y && diff <= self.right_symbol.width/2) {\n\t              hasSymbolUnder = true;\n\t              break;\n\t            }\n\t          }\n\t        }\n\t\n\t        if (hasSymbolUnder) {\n\t          if (self.right_symbol.symbolType === 'end') return;\n\t          self.right_symbol.setX(symb.getX() + symb.width + lineLength);\n\t          shift();\n\t        }\n\t      })();\n\t\n\t      this.right_symbol.isPositioned = true;\n\t\n\t      this.right_symbol.render();\n\t    }\n\t  }\n\t  \n\t  if (this.left_symbol) {\n\t    var leftPoint = this.getLeft();\n\t  \n\t    if (!this.left_symbol.isPositioned) {\n\t      this.left_symbol.setY(leftPoint.y - this.left_symbol.height / 2);\n\t      this.left_symbol.shiftX(-(this.group.getBBox().x + this.width + lineLength));\n\t\n\t      (function shift() {\n\t        var hasSymbolUnder = false;\n\t        var symb;\n\t        for (var i = 0, len = self.chart.symbols.length; i < len; i++) {\n\t          symb = self.chart.symbols[i];\n\t    \n\t          if (!self.params['align-next'] || self.params['align-next'] !== 'no') {\n\t            var diff = Math.abs(symb.getCenter().x - self.left_symbol.getCenter().x);\n\t            if (symb.getCenter().y > self.left_symbol.getCenter().y && diff <= self.left_symbol.width / 2) {\n\t              hasSymbolUnder = true;\n\t              break;\n\t            }\n\t          }\n\t        }\n\t    \n\t        if (hasSymbolUnder) {\n\t          if (self.left_symbol.symbolType === 'end') return;\n\t          self.left_symbol.setX(symb.getX() + symb.width + lineLength);\n\t          shift();\n\t        }\n\t      })();\n\t  \n\t      this.left_symbol.isPositioned = true;\n\t  \n\t      this.left_symbol.render();\n\t    }\n\t  }\n\t};\n\t\n\tCondition.prototype.renderLines = function() {\n\t  if (this.yes_symbol) {\n\t    this.drawLineTo(this.yes_symbol, this.yes_annotation ? this.yes_annotation : this.getAttr('yes-text'), this.yes_direction);\n\t  }\n\t\n\t  if (this.no_symbol) {\n\t    this.drawLineTo(this.no_symbol, this.no_annotation ? this.no_annotation : this.getAttr('no-text'), this.no_direction);\n\t  }\n\t};\n\t\n\tmodule.exports = Condition;\n\n\n/***/ }),\n/* 6 */\n/*!******************************************!*\\\n  !*** ./src/flowchart.symbol.parallel.js ***!\n  \\******************************************/\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Symbol = __webpack_require__(/*! ./flowchart.symbol */ 2);\n\tvar inherits = __webpack_require__(/*! ./flowchart.helpers */ 1).inherits;\n\t\n\tfunction Parallel(chart, options) {\n\t  var symbol = chart.paper.rect(0, 0, 0, 0);\n\t  options = options || {};\n\t  Symbol.call(this, chart, options, symbol);\n\t  this.path1_annotation = options.path1_annotation || '';\n\t  this.path2_annotation = options.path2_annotation || '';\n\t  this.path3_annotation = options.path3_annotation || '';\n\t  this.textMargin = this.getAttr('text-margin');\n\t  this.path1_direction = 'bottom';\n\t  this.path2_direction = 'right';\n\t  this.path3_direction = 'top';\n\t  this.params = options.params;\n\t  if (options.direction_next === 'path1' && !options[options.direction_next] && options.next) {\n\t    options[options.direction_next] = options.next;\n\t  }\n\t  if (options.direction_next === 'path2' && !options[options.direction_next] && options.next) {\n\t    options[options.direction_next] = options.next;\n\t  }\n\t  if (options.direction_next === 'path3' && !options[options.direction_next] && options.next) {\n\t    options[options.direction_next] = options.next;\n\t  }\n\t\n\t  if (options.path1 && options.direction_path1 && options.path2 && !options.direction_path2 && options.path3 && !options.direction_path3) {\n\t    if (options.direction_path1 === 'right') {\n\t      this.path2_direction = 'bottom';\n\t      this.path1_direction = 'right';\n\t      this.path3_direction = 'top';\n\t    } else if (options.direction_path1 === 'top') {\n\t      this.path2_direction = 'right';\n\t      this.path1_direction = 'top';\n\t      this.path3_direction = 'bottom';\n\t    } else if (options.direction_path1 === 'left') {\n\t      this.path2_direction = 'right';\n\t      this.path1_direction = 'left';\n\t      this.path3_direction = 'bottom';\n\t    } else {\n\t      this.path2_direction = 'right';\n\t      this.path1_direction = 'bottom';\n\t      this.path3_direction = 'top';\n\t    }\n\t  } else if (options.path1 && !options.direction_path1 && options.path2 && options.direction_path2 && options.path3 && !options.direction_path3) {\n\t    if (options.direction_path2 === 'right') {\n\t      this.path1_direction = 'bottom';\n\t      this.path2_direction = 'right';\n\t      this.path3_direction = 'top';\n\t    } else if (options.direction_path2 === 'left') {\n\t      this.path1_direction = 'bottom';\n\t      this.path2_direction = 'left';\n\t      this.path3_direction = 'right';\n\t    } else {\n\t      this.path1_direction = 'right';\n\t      this.path2_direction = 'bottom';\n\t      this.path3_direction = 'top';\n\t    }\n\t  } else if (options.path1 && !options.direction_path1 && options.path2 && !options.direction_path2 && options.path3 && options.direction_path3) {\n\t    if (options.direction_path2 === 'right') {\n\t      this.path1_direction = 'bottom';\n\t      this.path2_direction = 'top';\n\t      this.path3_direction = 'right';\n\t    } else if (options.direction_path2 === 'left') {\n\t      this.path1_direction = 'bottom';\n\t      this.path2_direction = 'right';\n\t      this.path3_direction = 'left';\n\t    } else {\n\t      this.path1_direction = 'right';\n\t      this.path2_direction = 'bottom';\n\t      this.path3_direction = 'top';\n\t    }\n\t  } else {\n\t    this.path1_direction = options.direction_path1;\n\t    this.path2_direction = options.direction_path2;\n\t    this.path3_direction = options.direction_path3;\n\t  }\n\t\n\t  this.path1_direction = this.path1_direction || 'bottom';\n\t  this.path2_direction = this.path2_direction || 'right';\n\t  this.path3_direction = this.path3_direction || 'top';\n\t\n\t  this.initialize();\n\t}\n\tinherits(Parallel, Symbol);\n\t\n\tParallel.prototype.render = function() {\n\t  if (this.path1_direction) {\n\t    this[this.path1_direction + '_symbol'] = this.path1_symbol;\n\t  }\n\t\n\t  if (this.path2_direction) {\n\t    this[this.path2_direction + '_symbol'] = this.path2_symbol;\n\t  }\n\t\n\t  if (this.path3_direction) {\n\t    this[this.path3_direction + '_symbol'] = this.path3_symbol;\n\t  }\n\t\n\t  var lineLength = this.getAttr('line-length');\n\t\n\t  if (this.bottom_symbol) {\n\t    var bottomPoint = this.getBottom();\n\t\n\t    if (!this.bottom_symbol.isPositioned) {\n\t      this.bottom_symbol.shiftY(this.getY() + this.height + lineLength);\n\t      this.bottom_symbol.setX(bottomPoint.x - this.bottom_symbol.width / 2);\n\t      this.bottom_symbol.isPositioned = true;\n\t\n\t      this.bottom_symbol.render();\n\t    }\n\t  }\n\t\n\t  if (this.top_symbol) {\n\t    var topPoint = this.getTop();\n\t\n\t    if (!this.top_symbol.isPositioned) {\n\t      this.top_symbol.shiftY(this.getY() - this.top_symbol.height - lineLength);\n\t      this.top_symbol.setX(topPoint.x + this.top_symbol.width);\n\t      this.top_symbol.isPositioned = true;\n\t\n\t      this.top_symbol.render();\n\t    }\n\t  }\n\t\n\t  var self = this;\n\t\n\t  if (this.left_symbol) {\n\t    var leftPoint = this.getLeft();\n\t\n\t    if (!this.left_symbol.isPositioned) {\n\t      this.left_symbol.setY(leftPoint.y - this.left_symbol.height / 2);\n\t      this.left_symbol.shiftX(-(this.group.getBBox().x + this.width + lineLength));\n\t      (function shift() {\n\t        var hasSymbolUnder = false;\n\t        var symb;\n\t        for (var i = 0, len = self.chart.symbols.length; i < len; i++) {\n\t          symb = self.chart.symbols[i];\n\t\n\t          if (!self.params['align-next'] || self.params['align-next'] !== 'no') {\n\t            var diff = Math.abs(symb.getCenter().x - self.left_symbol.getCenter().x);\n\t            if (symb.getCenter().y > self.left_symbol.getCenter().y && diff <= self.left_symbol.width / 2) {\n\t              hasSymbolUnder = true;\n\t              break;\n\t            }\n\t          }\n\t        }\n\t\n\t        if (hasSymbolUnder) {\n\t          if (self.left_symbol.symbolType === 'end') return;\n\t          self.left_symbol.setX(symb.getX() + symb.width + lineLength);\n\t          shift();\n\t        }\n\t      })();\n\t\n\t      this.left_symbol.isPositioned = true;\n\t\n\t      this.left_symbol.render();\n\t    }\n\t  }\n\t\n\t  if (this.right_symbol) {\n\t    var rightPoint = this.getRight();\n\t\n\t    if (!this.right_symbol.isPositioned) {\n\t      this.right_symbol.setY(rightPoint.y - this.right_symbol.height / 2);\n\t      this.right_symbol.shiftX(this.group.getBBox().x + this.width + lineLength);\n\t      (function shift() {\n\t        var hasSymbolUnder = false;\n\t        var symb;\n\t        for (var i = 0, len = self.chart.symbols.length; i < len; i++) {\n\t          symb = self.chart.symbols[i];\n\t\n\t          if (!self.params['align-next'] || self.params['align-next'] !== 'no') {\n\t            var diff = Math.abs(symb.getCenter().x - self.right_symbol.getCenter().x);\n\t            if (symb.getCenter().y > self.right_symbol.getCenter().y && diff <= self.right_symbol.width / 2) {\n\t              hasSymbolUnder = true;\n\t              break;\n\t            }\n\t          }\n\t        }\n\t\n\t        if (hasSymbolUnder) {\n\t          if (self.right_symbol.symbolType === 'end') return;\n\t          self.right_symbol.setX(symb.getX() + symb.width + lineLength);\n\t          shift();\n\t        }\n\t      })();\n\t\n\t      this.right_symbol.isPositioned = true;\n\t\n\t      this.right_symbol.render();\n\t    }\n\t  }\n\t};\n\t\n\tParallel.prototype.renderLines = function() {\n\t  if (this.path1_symbol) {\n\t    this.drawLineTo(this.path1_symbol, this.path1_annotation, this.path1_direction);\n\t  }\n\t\n\t  if (this.path2_symbol) {\n\t    this.drawLineTo(this.path2_symbol, this.path2_annotation, this.path2_direction);\n\t  }\n\t\n\t  if (this.path3_symbol) {\n\t    this.drawLineTo(this.path3_symbol, this.path3_annotation, this.path3_direction);\n\t  }\n\t};\n\t\n\tmodule.exports = Parallel;\n\n/***/ }),\n/* 7 */\n/*!********************************!*\\\n  !*** ./src/flowchart.chart.js ***!\n  \\********************************/\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Raphael = __webpack_require__(/*! raphael */ 18);\n\tvar defaults = __webpack_require__(/*! ./flowchart.helpers */ 1).defaults;\n\tvar defaultOptions = __webpack_require__(/*! ./flowchart.defaults */ 8);\n\tvar Condition = __webpack_require__(/*! ./flowchart.symbol.condition */ 5);\n\tvar Parallel = __webpack_require__(/*! ./flowchart.symbol.parallel */ 6);\n\t\n\tfunction FlowChart(container, options) {\n\t  options = options || {};\n\t\n\t  this.paper = new Raphael(container);\n\t\n\t  this.options = defaults(options, defaultOptions);\n\t\n\t  this.symbols = [];\n\t  this.lines = [];\n\t  this.start = null;\n\t}\n\t\n\tFlowChart.prototype.handle = function(symbol) {\n\t  if (this.symbols.indexOf(symbol) <= -1) {\n\t    this.symbols.push(symbol);\n\t  }\n\t\n\t  var flowChart = this;\n\t\n\t  if (symbol instanceof(Condition)) {\n\t    symbol.yes = function(nextSymbol) {\n\t      symbol.yes_symbol = nextSymbol;\n\t      if(symbol.no_symbol) {\n\t        symbol.pathOk = true;\n\t      }\n\t      return flowChart.handle(nextSymbol);\n\t    };\n\t    symbol.no = function(nextSymbol) {\n\t      symbol.no_symbol = nextSymbol;\n\t      if (symbol.yes_symbol) {\n\t        symbol.pathOk = true;\n\t      }\n\t      return flowChart.handle(nextSymbol);\n\t    };\n\t  } else if (symbol instanceof(Parallel)) {\n\t    symbol.path1 = function(nextSymbol) {\n\t      symbol.path1_symbol = nextSymbol;\n\t      if (symbol.path2_symbol) {\n\t        symbol.pathOk = true;\n\t      }\n\t      return flowChart.handle(nextSymbol);\n\t    };\n\t    symbol.path2 = function(nextSymbol) {\n\t      symbol.path2_symbol = nextSymbol;\n\t      if (symbol.path3_symbol) {\n\t        symbol.pathOk = true;\n\t      }\n\t      return flowChart.handle(nextSymbol);\n\t    };\n\t    symbol.path3 = function(nextSymbol) {\n\t      symbol.path3_symbol = nextSymbol;\n\t      if (symbol.path1_symbol) {\n\t        symbol.pathOk = true;\n\t      }\n\t      return flowChart.handle(nextSymbol);\n\t    };\n\t  } else {\n\t    symbol.then = function(nextSymbol) {\n\t      symbol.next = nextSymbol;\n\t      symbol.pathOk = true;\n\t      return flowChart.handle(nextSymbol);\n\t    };\n\t  }\n\t\n\t  return symbol;\n\t};\n\t\n\tFlowChart.prototype.startWith = function(symbol) {\n\t  this.start = symbol;\n\t  return this.handle(symbol);\n\t};\n\t\n\tFlowChart.prototype.render = function() {\n\t  var maxWidth = 0,\n\t    maxHeight = 0,\n\t    i = 0,\n\t    len = 0,\n\t    maxX = 0,\n\t    maxY = 0,\n\t    minX = 0,\n\t    minY = 0,\n\t    symbol,\n\t    line;\n\t\n\t  for (i = 0, len = this.symbols.length; i < len; i++) {\n\t    symbol = this.symbols[i];\n\t    if (symbol.width > maxWidth) {\n\t      maxWidth = symbol.width;\n\t    }\n\t    if (symbol.height > maxHeight) {\n\t      maxHeight = symbol.height;\n\t    }\n\t  }\n\t\n\t  for (i = 0, len = this.symbols.length; i < len; i++) {\n\t    symbol = this.symbols[i];\n\t    symbol.shiftX(this.options.x + (maxWidth - symbol.width)/2 + this.options['line-width']);\n\t    symbol.shiftY(this.options.y + (maxHeight - symbol.height)/2 + this.options['line-width']);\n\t  }\n\t\n\t  this.start.render();\n\t  // for (i = 0, len = this.symbols.length; i < len; i++) {\n\t  //   symbol = this.symbols[i];\n\t  //   symbol.render();\n\t  // }\n\t\n\t  for (i = 0, len = this.symbols.length; i < len; i++) {\n\t    symbol = this.symbols[i];\n\t    symbol.renderLines();\n\t  }\n\t\n\t  maxX = this.maxXFromLine;\n\t\n\t  var x;\n\t  var y;\n\t\n\t  for (i = 0, len = this.symbols.length; i < len; i++) {\n\t    symbol = this.symbols[i];\n\t    var leftX = symbol.getX()\n\t    x = leftX + symbol.width;\n\t    y = symbol.getY() + symbol.height;\n\t    if (leftX < minX) {\n\t      minX = leftX;\n\t    }\n\t    if (x > maxX) {\n\t      maxX = x;\n\t    }\n\t    if (y > maxY) {\n\t      maxY = y;\n\t    }\n\t  }\n\t\n\t  for (i = 0, len = this.lines.length; i < len; i++) {\n\t    line = this.lines[i].getBBox();\n\t    x = line.x;\n\t    y = line.y;\n\t    var x2 = line.x2;\n\t    var y2 = line.y2;\n\t    if (x < minX) {\n\t      minX = x;\n\t    }\n\t    if (y < minY) {\n\t      minY = y;\n\t    }\n\t    if (x2 > maxX) {\n\t      maxX = x2;\n\t    }\n\t    if (y2 > maxY) {\n\t      maxY = y2;\n\t    }\n\t  }\n\t\n\t  var scale = this.options['scale'];\n\t  var lineWidth = this.options['line-width'];\n\t\n\t  if (this.minXFromSymbols < minX) minX = this.minXFromSymbols;\n\t\n\t  if (minX < 0) minX -= lineWidth;\n\t  if (minY < 0) minY -= lineWidth;\n\t\n\t  var width = maxX + lineWidth - minX;\n\t  var height = maxY + lineWidth - minY;\n\t\n\t  this.paper.setSize(width * scale, height * scale);\n\t  this.paper.setViewBox(minX, minY, width, height, true);\n\t};\n\t\n\tFlowChart.prototype.clean = function() {\n\t  if (this.paper) {\n\t    var paperDom = this.paper.canvas;\n\t    paperDom.parentNode && paperDom.parentNode.removeChild(paperDom);\n\t  }\n\t};\n\t\n\tmodule.exports = FlowChart;\n\n/***/ }),\n/* 8 */\n/*!***********************************!*\\\n  !*** ./src/flowchart.defaults.js ***!\n  \\***********************************/\n/***/ (function(module, exports) {\n\n\t// defaults\n\tmodule.exports = {\n\t  'x': 0,\n\t  'y': 0,\n\t  // 'roundness': 0,\n\t  'line-width': 3,\n\t  'line-length': 50,\n\t  'text-margin': 10,\n\t  'font-size': 14,\n\t  'font-color': 'black',\n\t  // 'font': 'normal',\n\t  // 'font-family': 'calibri',\n\t  // 'font-weight': 'normal',\n\t  'line-color': 'black',\n\t  'element-color': 'black',\n\t  'fill': 'white',\n\t  'yes-text': 'yes',\n\t  'no-text': 'no',\n\t  'arrow-end': 'block',\n\t  'class': 'flowchart',\n\t  'scale': 1,\n\t  'symbols': {\n\t    'start': {},\n\t    'end': {},\n\t    'condition': {},\n\t    'inputoutput': {},\n\t    'input': {}, //tds\n\t    'output': {}, //tds    \n\t    'operation': {},\n\t    'subroutine': {},\n\t    'parallel': {}\n\t  } //,\n\t  // 'flowstate' : {\n\t  //   'past' : { 'fill': '#CCCCCC', 'font-size': 12},\n\t  //   'current' : {'fill': 'yellow', 'font-color': 'red', 'font-weight': 'bold'},\n\t  //   'future' : { 'fill': '#FFFF99'},\n\t  //   'invalid': {'fill': '#444444'}\n\t  // }\n\t};\n\n/***/ }),\n/* 9 */\n/*!*******************************!*\\\n  !*** ./src/flowchart.shim.js ***!\n  \\*******************************/\n/***/ (function(module, exports) {\n\n\t// add indexOf to non ECMA-262 standard compliant browsers\n\tif (!Array.prototype.indexOf) {\n\t  Array.prototype.indexOf = function (searchElement /*, fromIndex */ ) {\n\t    \"use strict\";\n\t    if (this === null) {\n\t      throw new TypeError();\n\t    }\n\t    var t = Object(this);\n\t    var len = t.length >>> 0;\n\t    if (len === 0) {\n\t      return -1;\n\t    }\n\t    var n = 0;\n\t    if (arguments.length > 0) {\n\t      n = Number(arguments[1]);\n\t      if (n != n) { // shortcut for verifying if it's NaN\n\t        n = 0;\n\t      } else if (n !== 0 && n != Infinity && n != -Infinity) {\n\t        n = (n > 0 || -1) * Math.floor(Math.abs(n));\n\t      }\n\t    }\n\t    if (n >= len) {\n\t      return -1;\n\t    }\n\t    var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);\n\t    for (; k < len; k++) {\n\t      if (k in t && t[k] === searchElement) {\n\t        return k;\n\t      }\n\t    }\n\t    return -1;\n\t  };\n\t}\n\t\n\t// add lastIndexOf to non ECMA-262 standard compliant browsers\n\tif (!Array.prototype.lastIndexOf) {\n\t  Array.prototype.lastIndexOf = function(searchElement /*, fromIndex*/) {\n\t    \"use strict\";\n\t    if (this === null) {\n\t      throw new TypeError();\n\t    }\n\t    var t = Object(this);\n\t    var len = t.length >>> 0;\n\t    if (len === 0) {\n\t      return -1;\n\t    }\n\t    var n = len;\n\t    if (arguments.length > 1) {\n\t      n = Number(arguments[1]);\n\t      if (n != n) {\n\t        n = 0;\n\t      } else if (n !== 0 && n != (1 / 0) && n != -(1 / 0)) {\n\t        n = (n > 0 || -1) * Math.floor(Math.abs(n));\n\t      }\n\t    }\n\t    var k = n >= 0 ? Math.min(n, len - 1) : len - Math.abs(n);\n\t    for (; k >= 0; k--) {\n\t      if (k in t && t[k] === searchElement) {\n\t        return k;\n\t      }\n\t    }\n\t    return -1;\n\t  };\n\t}\n\t\n\tif (!String.prototype.trim) {\n\t  String.prototype.trim = function() {\n\t    return this.replace(/^\\s+|\\s+$/g, '');\n\t  };\n\t}\n\n/***/ }),\n/* 10 */\n/*!*************************************!*\\\n  !*** ./src/flowchart.symbol.end.js ***!\n  \\*************************************/\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Symbol = __webpack_require__(/*! ./flowchart.symbol */ 2);\n\tvar inherits = __webpack_require__(/*! ./flowchart.helpers */ 1).inherits;\n\t\n\tfunction End(chart, options) {\n\t  var symbol = chart.paper.rect(0, 0, 0, 0, 20);\n\t  options = options || {};\n\t  options.text = options.text || 'End';\n\t  Symbol.call(this, chart, options, symbol);\n\t}\n\tinherits(End, Symbol);\n\t\n\tmodule.exports = End;\n\n\n/***/ }),\n/* 11 */\n/*!***************************************!*\\\n  !*** ./src/flowchart.symbol.input.js ***!\n  \\***************************************/\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Symbol = __webpack_require__(/*! ./flowchart.symbol */ 2);\n\tvar inherits = __webpack_require__(/*! ./flowchart.helpers */ 1).inherits;\n\tvar drawAPI = __webpack_require__(/*! ./flowchart.functions */ 3);\n\tvar drawPath = drawAPI.drawPath;\n\t\n\tfunction Input(chart, options) {\n\t  options = options || {};\n\t  Symbol.call(this, chart, options);\n\t  this.textMargin = this.getAttr('text-margin');\n\t\n\t  this.text.attr({\n\t    x: this.textMargin * 3\n\t  });\n\t\n\t  var width = this.text.getBBox().width + 4 * this.textMargin;\n\t  var height = this.text.getBBox().height + 2 * this.textMargin;\n\t  var startX = this.textMargin;\n\t  var startY = height/2;\n\t\n\t  var start = {x: startX, y: startY};\n\t  var points = [\n\t    {x: startX - this.textMargin + 2 * this.textMargin, y: height},\n\t    {x: startX - this.textMargin + width, y: height},\n\t    {x: startX - this.textMargin + width + 2 * this.textMargin, y: 0},\n\t    {x: startX - this.textMargin, y: 0},\n\t    {x: startX, y: startY}\n\t  ];\n\t\n\t  var symbol = drawPath(chart, start, points);\n\t\n\t  symbol.attr({\n\t    stroke: this.getAttr('element-color'),\n\t    'stroke-width': this.getAttr('line-width'),\n\t    fill: this.getAttr('fill')\n\t  });\n\t  if (options.link) { symbol.attr('href', options.link); }\n\t  if (options.target) { symbol.attr('target', options.target); }\n\t  if (options.key) { symbol.node.id = options.key; }\n\t  symbol.node.setAttribute('class', this.getAttr('class'));\n\t\n\t  this.text.attr({\n\t    y: symbol.getBBox().height/2\n\t  });\n\t\n\t  this.group.push(symbol);\n\t  symbol.insertBefore(this.text);\n\t  this.symbol = symbol\n\t\n\t  this.initialize();\n\t}\n\tinherits(Input, Symbol);\n\t\n\tInput.prototype.getLeft = function() {\n\t  var y = this.getY() + this.group.getBBox().height/2;\n\t  var x = this.getX() + this.textMargin;\n\t  return {x: x, y: y};\n\t};\n\t\n\tInput.prototype.getRight = function() {\n\t  var y = this.getY() + this.group.getBBox().height/2;\n\t  var x = this.getX() + this.group.getBBox().width - this.textMargin;\n\t  return {x: x, y: y};\n\t};\n\t\n\tmodule.exports = Input;\n\t\n\t\n\n\n/***/ }),\n/* 12 */\n/*!*********************************************!*\\\n  !*** ./src/flowchart.symbol.inputoutput.js ***!\n  \\*********************************************/\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Symbol = __webpack_require__(/*! ./flowchart.symbol */ 2);\n\tvar inherits = __webpack_require__(/*! ./flowchart.helpers */ 1).inherits;\n\tvar drawAPI = __webpack_require__(/*! ./flowchart.functions */ 3);\n\tvar drawPath = drawAPI.drawPath;\n\t\n\tfunction InputOutput(chart, options) {\n\t  options = options || {};\n\t  Symbol.call(this, chart, options);\n\t  this.textMargin = this.getAttr('text-margin');\n\t\n\t  this.text.attr({\n\t    x: this.textMargin * 3\n\t  });\n\t\n\t  var width = this.text.getBBox().width + 4 * this.textMargin;\n\t  var height = this.text.getBBox().height + 2 * this.textMargin;\n\t  var startX = this.textMargin;\n\t  var startY = height/2;\n\t\n\t  var start = {x: startX, y: startY};\n\t  var points = [\n\t    {x: startX - this.textMargin, y: height},\n\t    {x: startX - this.textMargin + width, y: height},\n\t    {x: startX - this.textMargin + width + 2 * this.textMargin, y: 0},\n\t    {x: startX - this.textMargin + 2 * this.textMargin, y: 0},\n\t    {x: startX, y: startY}\n\t  ];\n\t\n\t  var symbol = drawPath(chart, start, points);\n\t\n\t  symbol.attr({\n\t    stroke: this.getAttr('element-color'),\n\t    'stroke-width': this.getAttr('line-width'),\n\t    fill: this.getAttr('fill')\n\t  });\n\t  if (options.link) { symbol.attr('href', options.link); }\n\t  if (options.target) { symbol.attr('target', options.target); }\n\t  if (options.key) { symbol.node.id = options.key; }\n\t  symbol.node.setAttribute('class', this.getAttr('class'));\n\t\n\t  this.text.attr({\n\t    y: symbol.getBBox().height/2\n\t  });\n\t\n\t  this.group.push(symbol);\n\t  symbol.insertBefore(this.text);\n\t  this.symbol = symbol\n\t\n\t  this.initialize();\n\t}\n\tinherits(InputOutput, Symbol);\n\t\n\tInputOutput.prototype.getLeft = function() {\n\t  var y = this.getY() + this.group.getBBox().height/2;\n\t  var x = this.getX() + this.textMargin;\n\t  return {x: x, y: y};\n\t};\n\t\n\tInputOutput.prototype.getRight = function() {\n\t  var y = this.getY() + this.group.getBBox().height/2;\n\t  var x = this.getX() + this.group.getBBox().width - this.textMargin;\n\t  return {x: x, y: y};\n\t};\n\t\n\tmodule.exports = InputOutput;\n\n\n/***/ }),\n/* 13 */\n/*!*******************************************!*\\\n  !*** ./src/flowchart.symbol.operation.js ***!\n  \\*******************************************/\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Symbol = __webpack_require__(/*! ./flowchart.symbol */ 2);\n\tvar inherits = __webpack_require__(/*! ./flowchart.helpers */ 1).inherits;\n\t\n\tfunction Operation(chart, options) {\n\t  var symbol = chart.paper.rect(0, 0, 0, 0);\n\t  options = options || {};\n\t  Symbol.call(this, chart, options, symbol);\n\t}\n\tinherits(Operation, Symbol);\n\t\n\tmodule.exports = Operation;\n\n\n/***/ }),\n/* 14 */\n/*!****************************************!*\\\n  !*** ./src/flowchart.symbol.output.js ***!\n  \\****************************************/\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Symbol = __webpack_require__(/*! ./flowchart.symbol */ 2);\n\tvar inherits = __webpack_require__(/*! ./flowchart.helpers */ 1).inherits;\n\tvar drawAPI = __webpack_require__(/*! ./flowchart.functions */ 3);\n\tvar drawPath = drawAPI.drawPath;\n\t\n\tfunction Output(chart, options) {\n\t  options = options || {};\n\t  Symbol.call(this, chart, options);\n\t  this.textMargin = this.getAttr('text-margin');\n\t\n\t  this.text.attr({\n\t    x: this.textMargin * 3\n\t  });\n\t\n\t  var width = this.text.getBBox().width + 4 * this.textMargin;\n\t  var height = this.text.getBBox().height + 2 * this.textMargin;\n\t  var startX = this.textMargin;\n\t  var startY = height/2;\n\t\n\t  var start = {x: startX, y: startY};\n\t  var points = [\n\t    {x: startX - this.textMargin, y: height},\n\t    {x: startX - this.textMargin + width + 2 * this.textMargin, y: height},\n\t    {x: startX - this.textMargin + width, y: 0},\n\t    {x: startX - this.textMargin + 2 * this.textMargin, y: 0},\n\t    {x: startX, y: startY}\n\t  ];\n\t\n\t  var symbol = drawPath(chart, start, points);\n\t\n\t  symbol.attr({\n\t    stroke: this.getAttr('element-color'),\n\t    'stroke-width': this.getAttr('line-width'),\n\t    fill: this.getAttr('fill')\n\t  });\n\t  if (options.link) { symbol.attr('href', options.link); }\n\t  if (options.target) { symbol.attr('target', options.target); }\n\t  if (options.key) { symbol.node.id = options.key; }\n\t  symbol.node.setAttribute('class', this.getAttr('class'));\n\t\n\t  this.text.attr({\n\t    y: symbol.getBBox().height/2\n\t  });\n\t\n\t  this.group.push(symbol);\n\t  symbol.insertBefore(this.text);\n\t  this.symbol = symbol\n\t\n\t  this.initialize();\n\t}\n\tinherits(Output, Symbol);\n\t\n\tOutput.prototype.getLeft = function() {\n\t  var y = this.getY() + this.group.getBBox().height/2;\n\t  var x = this.getX() + this.textMargin;\n\t  return {x: x, y: y};\n\t};\n\t\n\tOutput.prototype.getRight = function() {\n\t  var y = this.getY() + this.group.getBBox().height/2;\n\t  var x = this.getX() + this.group.getBBox().width - this.textMargin;\n\t  return {x: x, y: y};\n\t};\n\t\n\tmodule.exports = Output;\n\t\n\t\n\t\n\t/*\n\t//var Symbol = require('./flowchart.symbol');\n\tvar inherits = require('./flowchart.helpers').inherits;\n\tvar drawAPI = require('./flowchart.functions');\n\tvar InputOutput = require('./flowchart.symbol.inputoutput');\n\tvar drawPath = drawAPI.drawPath;\n\t\n\tfunction Output(chart, options) {\n\t  options = options || {};\n\t  InputOutput.call(this, chart, options);\n\t\n\t  var width = this.text.getBBox().width + 4 * this.textMargin;\n\t  var height = this.text.getBBox().height + 2 * this.textMargin;\n\t  var startX = this.textMargin;\n\t  var startY = height/2;\n\t\n\t  var start = {x: startX, y: startY};\n\t  var points = [\n\t    {x: startX - this.textMargin + 2 * this.textMargin, y: height},\n\t    {x: startX - this.textMargin + width, y: height},\n\t    {x: startX - this.textMargin + width + 2 * this.textMargin, y: 0},\n\t    {x: startX - this.textMargin, y: 0},\n\t    {x: startX, y: startY}\n\t  ];\n\t\n\t  var symbol = drawPath(chart, start, points);\n\t\n\t  symbol.attr({\n\t    stroke: this.getAttr('element-color'),\n\t    'stroke-width': this.getAttr('line-width'),\n\t    fill: this.getAttr('fill')\n\t  });\n\t  if (options.link) { symbol.attr('href', options.link); }\n\t  if (options.target) { symbol.attr('target', options.target); }\n\t  if (options.key) { symbol.node.id = options.key; }\n\t  symbol.node.setAttribute('class', this.getAttr('class'));\n\t\n\t  this.text.attr({\n\t    y: symbol.getBBox().height/2\n\t  });\n\t\n\t  this.group.push(symbol);\n\t  symbol.insertBefore(this.text);\n\t    \n\t  if (this.symbol){\n\t    this.group.remove(this.symbol); //tds\n\t    this.symbol.parentNode.removeChild(this.symbol); //tds\n\t  }\n\t  this.symbol = symbol\n\t\n\t  this.initialize();\n\t}\n\tinherits(Output, InputOutput);\n\t\n\tmodule.exports = Output;\n\t*/\n\n\n/***/ }),\n/* 15 */\n/*!***************************************!*\\\n  !*** ./src/flowchart.symbol.start.js ***!\n  \\***************************************/\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Symbol = __webpack_require__(/*! ./flowchart.symbol */ 2);\n\tvar inherits = __webpack_require__(/*! ./flowchart.helpers */ 1).inherits;\n\t\n\tfunction Start(chart, options) {\n\t  var symbol = chart.paper.rect(0, 0, 0, 0, 20);\n\t  options = options || {};\n\t  options.text = options.text || 'Start';\n\t  Symbol.call(this, chart, options, symbol);\n\t}\n\tinherits(Start, Symbol);\n\t\n\tmodule.exports = Start;\n\t\n\t// Start.prototype.render = function() {\n\t//   if (this.next) {\n\t//     var lineLength = this.chart.options.symbols[this.symbolType]['line-length'] || this.chart.options['line-length'];\n\t\n\t//     var bottomPoint = this.getBottom();\n\t//     var topPoint = this.next.getTop();\n\t\n\t//     if (!this.next.isPositioned) {\n\t//       this.next.shiftY(this.getY() + this.height + lineLength);\n\t//       this.next.setX(bottomPoint.x - this.next.width/2);\n\t//       this.next.isPositioned = true;\n\t\n\t//       this.next.render();\n\t//     }\n\t//   }\n\t// };\n\t\n\t// Start.prototype.renderLines = function() {\n\t//   if (this.next) {\n\t//     this.drawLineTo(this.next);\n\t//   }\n\t// };\n\n\n/***/ }),\n/* 16 */\n/*!********************************************!*\\\n  !*** ./src/flowchart.symbol.subroutine.js ***!\n  \\********************************************/\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Symbol = __webpack_require__(/*! ./flowchart.symbol */ 2);\n\tvar inherits = __webpack_require__(/*! ./flowchart.helpers */ 1).inherits;\n\t\n\tfunction Subroutine(chart, options) {\n\t  var symbol = chart.paper.rect(0, 0, 0, 0);\n\t  options = options || {};\n\t  Symbol.call(this, chart, options, symbol);\n\t\n\t  symbol.attr({\n\t    width: this.text.getBBox().width + 4 * this.getAttr('text-margin')\n\t  });\n\t\n\t  this.text.attr({\n\t    'x': 2 * this.getAttr('text-margin')\n\t  });\n\t\n\t  var innerWrap = chart.paper.rect(0, 0, 0, 0);\n\t  innerWrap.attr({\n\t    x: this.getAttr('text-margin'),\n\t    stroke: this.getAttr('element-color'),\n\t    'stroke-width': this.getAttr('line-width'),\n\t    width: this.text.getBBox().width + 2 * this.getAttr('text-margin'),\n\t    height: this.text.getBBox().height + 2 * this.getAttr('text-margin'),\n\t    fill: this.getAttr('fill')\n\t  });\n\t  if (options.key) { innerWrap.node.id = options.key + 'i'; }\n\t\n\t  var font = this.getAttr('font');\n\t  var fontF = this.getAttr('font-family');\n\t  var fontW = this.getAttr('font-weight');\n\t\n\t  if (font) innerWrap.attr({ 'font': font });\n\t  if (fontF) innerWrap.attr({ 'font-family': fontF });\n\t  if (fontW) innerWrap.attr({ 'font-weight': fontW });\n\t\n\t  if (options.link) { innerWrap.attr('href', options.link); }\n\t  if (options.target) { innerWrap.attr('target', options.target); }\n\t  this.group.push(innerWrap);\n\t  innerWrap.insertBefore(this.text);\n\t\n\t  this.initialize();\n\t}\n\tinherits(Subroutine, Symbol);\n\t\n\tmodule.exports = Subroutine;\n\n\n/***/ }),\n/* 17 */\n/*!******************************!*\\\n  !*** ./src/jquery-plugin.js ***!\n  \\******************************/\n/***/ (function(module, exports, __webpack_require__) {\n\n\tif (typeof jQuery != 'undefined') {\n\t\tvar parse = __webpack_require__(/*! ./flowchart.parse */ 4);\n\t\n\t\t(function( $ ) {\n\t\t\tfunction paramFit(needle, haystack) {\n\t\t\t\treturn needle == haystack ||\n\t\t\t\t( Array.isArray(haystack) && (haystack.includes(needle) || haystack.includes(Number(needle)) ))\n\t\t\t}\n\t\t\tvar methods = {\n\t\t\t\tinit : function(options) {\n\t\t\t\t\treturn this.each(function() {\n\t\t\t\t\t\tvar $this = $(this);\n\t\t\t\t\t\tthis.chart = parse($this.text());\n\t\t\t\t\t\t$this.html('');\n\t\t\t\t\t\tthis.chart.drawSVG(this, options);\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\tsetFlowStateByParam : function(param, paramValue, newFlowState) {\n\t\t\t\t\treturn this.each(function() {\n\t\t\t\t\t\tvar chart = this.chart;\n\t\n\t\t\t\t\t\t// @todo this should be part of Symbol API\n\t\t\t\t\t\tvar nextSymbolKeys = ['next', 'yes', 'no', 'path1', 'path2', 'path3'];\n\t\n\t\t\t\t\t\tfor (var property in chart.symbols) {\n\t\t\t\t\t\t\tif (chart.symbols.hasOwnProperty(property)) {\n\t\t\t\t\t\t\t\tvar symbol = chart.symbols[property];\n\t\t\t\t\t\t\t\tvar val = symbol.params[param];\n\t\t\t\t\t\t\t\tif (paramFit(val, paramValue)) {\n\t\t\t\t\t\t\t\t\tsymbol.flowstate = newFlowState;\n\t\t\t\t\t\t\t\t\tfor (var nski = 0; nski < nextSymbolKeys.length; nski++) {\n\t\t\t\t\t\t\t\t\t\tvar nextSymbolKey = nextSymbolKeys[nski];\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\tsymbol[nextSymbolKey] &&\n\t\t\t\t\t\t\t\t\t\t\tsymbol[nextSymbolKey]['params'] &&\n\t\t\t\t\t\t\t\t\t\t\tsymbol[nextSymbolKey]['params'][param] &&\n\t\t\t\t\t\t\t\t\t\t\tparamFit(symbol[nextSymbolKey]['params'][param], paramValue)\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tsymbol.lineStyle[symbol[nextSymbolKey]['key']] = {stroke: chart.options()['flowstate'][newFlowState]['fill']};\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tchart.clean();\n\t\t\t\t\t\tchart.drawSVG(this);\n\t\t\t\t\t});\n\t\n\t\t\t\t},\n\t\t\t\tclearFlowState: function () {\n\t\t\t\t\treturn this.each(function() {\n\t\t\t\t\t\tvar chart = this.chart;\n\t\n\t\t\t\t\t\tfor (var property in chart.symbols) {\n\t\t\t\t\t\t\tif (chart.symbols.hasOwnProperty(property)) {\n\t\t\t\t\t\t\t\tvar node = chart.symbols[property];\n\t\t\t\t\t\t\t\tnode.flowstate = '';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tchart.clean();\n\t\t\t\t\t\tchart.drawSVG(this);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\t$.fn.flowChart = function(methodOrOptions) {\n\t\t\t\tif ( methods[methodOrOptions] ) {\n\t\t\t\t\treturn methods[ methodOrOptions ].apply( this, Array.prototype.slice.call( arguments, 1 ));\n\t\t\t\t} else if ( typeof methodOrOptions === 'object' || ! methodOrOptions ) {\n\t\t\t\t\t// Default to \"init\"\n\t\t\t\t\treturn methods.init.apply( this, arguments );\n\t\t\t\t} else {\n\t\t\t\t\t$.error( 'Method ' +  methodOrOptions + ' does not exist on jQuery.flowChart' );\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t})(jQuery); // eslint-disable-line\n\t}\n\n\n/***/ }),\n/* 18 */\n/*!**************************!*\\\n  !*** external \"Raphael\" ***!\n  \\**************************/\n/***/ (function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_18__;\n\n/***/ })\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// flowchart.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 0c167881307e9f1b2ebf","require('./src/flowchart.shim');\nvar parse = require('./src/flowchart.parse');\nrequire('./src/jquery-plugin');\n\nvar FlowChart = {\n\tparse: parse\n};\n\nif (typeof window !== 'undefined') {\n\twindow.flowchart = FlowChart;\n}\n\nmodule.exports = FlowChart;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./index.js\n// module id = 0\n// module chunks = 0","function _defaults(options, defaultOptions) {\n  if (!options || typeof options === 'function') {\n    return defaultOptions;\n  }\n\n  var merged = {};\n  for (var attrname in defaultOptions) {\n    merged[attrname] = defaultOptions[attrname];\n  }\n\n  for (attrname in options) {\n    if (options[attrname]) {\n      if (typeof merged[attrname] === 'object') {\n        merged[attrname] = _defaults(merged[attrname], options[attrname]);\n      } else {\n        merged[attrname] = options[attrname];\n      }\n    }\n  }\n  return merged;\n}\n\nfunction _inherits(ctor, superCtor) {\n  if (typeof(Object.create) === 'function') {\n    // implementation from standard node.js 'util' module\n    ctor.super_ = superCtor;\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  } else {\n    // old school shim for old browsers\n    ctor.super_ = superCtor;\n    var TempCtor = function () {};\n    TempCtor.prototype = superCtor.prototype;\n    ctor.prototype = new TempCtor();\n    ctor.prototype.constructor = ctor;\n  }\n}\n\n// move dependent functions to a container so that\n// they can be overriden easier in no jquery environment (node.js)\nmodule.exports = {\n  defaults: _defaults,\n  inherits: _inherits\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/flowchart.helpers.js\n// module id = 1\n// module chunks = 0","var drawAPI = require('./flowchart.functions');\nvar drawLine = drawAPI.drawLine;\nvar checkLineIntersection = drawAPI.checkLineIntersection;\n\nfunction Symbol(chart, options, symbol) {\n  this.chart = chart;\n  this.group = this.chart.paper.set();\n  this.symbol = symbol;\n  this.connectedTo = [];\n  this.symbolType = options.symbolType;\n  this.flowstate = (options.flowstate || 'future');\n  this.lineStyle = (options.lineStyle || {});\n  this.key = (options.key || '');\n  this.leftLines = [];\n  this.rightLines = [];\n  this.topLines = [];\n  this.bottomLines = [];\n  this.params = options.params;\n\n  this.next_direction = options.next && options['direction_next'] ? options['direction_next'] : undefined;\n\n  this.text = this.chart.paper.text(0, 0, options.text);\n  //Raphael does not support the svg group tag so setting the text node id to the symbol node id plus t\n  if (options.key) { this.text.node.id = options.key + 't'; }\n  this.text.node.setAttribute('class', this.getAttr('class') + 't');\n\n  this.text.attr({\n    'text-anchor': 'start',\n    'x'          : this.getAttr('text-margin'),\n    'fill'       : this.getAttr('font-color'),\n    'font-size'  : this.getAttr('font-size')\n  });\n\n  var font  = this.getAttr('font');\n  var fontF = this.getAttr('font-family');\n  var fontW = this.getAttr('font-weight');\n\n  if (font) this.text.attr({ 'font': font });\n  if (fontF) this.text.attr({ 'font-family': fontF });\n  if (fontW) this.text.attr({ 'font-weight': fontW });\n\n  if (options.link) { this.text.attr('href', options.link); }\n  \n  //ndrqu Add click function with event and options params\n  if (options.function) { \n    this.text.attr({ 'cursor' : 'pointer' });\n\n    this.text.node.addEventListener(\"click\", function(evt) {\n        window[options.function](evt,options);\n    }, false);\n  }\n\n  if (options.target) { this.text.attr('target', options.target); }\n\n  var maxWidth = this.getAttr('maxWidth');\n  if (maxWidth) {\n    // using this approach: http://stackoverflow.com/a/3153457/22466\n    var words = options.text.split(' ');\n    var tempText = \"\";\n    for (var i=0, ii=words.length; i<ii; i++) {\n      var word = words[i];\n      this.text.attr(\"text\", tempText + \" \" + word);\n      if (this.text.getBBox().width > maxWidth) {\n        tempText += \"\\n\" + word;\n      } else {\n        tempText += \" \" + word;\n      }\n    }\n    this.text.attr(\"text\", tempText.substring(1));\n  }\n\n  this.group.push(this.text);\n\n  if (symbol) {\n    var tmpMargin = this.getAttr('text-margin');\n\n    symbol.attr({\n      'fill' : this.getAttr('fill'),\n      'stroke' : this.getAttr('element-color'),\n      'stroke-width' : this.getAttr('line-width'),\n      'width' : this.text.getBBox().width + 2 * tmpMargin,\n      'height' : this.text.getBBox().height + 2 * tmpMargin\n    });\n\n    symbol.node.setAttribute('class', this.getAttr('class'));\n    var roundness = this.getAttr('roundness');\n    if (!isNaN(roundness)) {\n      symbol.node.setAttribute('ry', roundness);\n      symbol.node.setAttribute('rx', roundness);\n    }\n\n    if (options.link) { symbol.attr('href', options.link); }\n    if (options.target) { symbol.attr('target', options.target); }\n\n    //ndrqu Add click function with event and options params\n    if (options.function) { \n        symbol.node.addEventListener(\"click\", function(evt) {\n          window[options.function](evt,options);\n        }, false);\n      symbol.attr({ 'cursor' : 'pointer' });\n    }\n    if (options.key) { symbol.node.id = options.key; }\n\n    this.group.push(symbol);\n    symbol.insertBefore(this.text);\n\n    this.text.attr({\n      'y': symbol.getBBox().height/2\n    });\n\n    this.initialize();\n  }\n\n}\n\n/* Gets the attribute based on Flowstate, Symbol-Name and default, first found wins */\nSymbol.prototype.getAttr = function(attName) {\n  if (!this.chart) {\n    return undefined;\n  }\n  var opt3 = (this.chart.options) ? this.chart.options[attName] : undefined;\n  var opt2 = (this.chart.options.symbols) ? this.chart.options.symbols[this.symbolType][attName] : undefined;\n  var opt1;\n  if (this.chart.options.flowstate && this.chart.options.flowstate[this.flowstate]) {\n    opt1 = this.chart.options.flowstate[this.flowstate][attName];\n  }\n  return (opt1 || opt2 || opt3);\n};\n\nSymbol.prototype.initialize = function() {\n  this.group.transform('t' + this.getAttr('line-width') + ',' + this.getAttr('line-width'));\n\n  this.width = this.group.getBBox().width;\n  this.height = this.group.getBBox().height;\n};\n\nSymbol.prototype.getCenter = function() {\n  return {x: this.getX() + this.width/2,\n          y: this.getY() + this.height/2};\n};\n\nSymbol.prototype.getX = function() {\n  return this.group.getBBox().x;\n};\n\nSymbol.prototype.getY = function() {\n  return this.group.getBBox().y;\n};\n\nSymbol.prototype.shiftX = function(x) {\n  this.group.transform('t' + (this.getX() + x) + ',' + this.getY());\n};\n\nSymbol.prototype.setX = function(x) {\n  this.group.transform('t' + x + ',' + this.getY());\n};\n\nSymbol.prototype.shiftY = function(y) {\n  this.group.transform('t' + this.getX() + ',' + (this.getY() + y));\n};\n\nSymbol.prototype.setY = function(y) {\n  this.group.transform('t' + this.getX() + ',' + y);\n};\n\nSymbol.prototype.getTop = function() {\n  var y = this.getY();\n  var x = this.getX() + this.width/2;\n  return {x: x, y: y};\n};\n\nSymbol.prototype.getBottom = function() {\n  var y = this.getY() + this.height;\n  var x = this.getX() + this.width/2;\n  return {x: x, y: y};\n};\n\nSymbol.prototype.getLeft = function() {\n  var y = this.getY() + this.group.getBBox().height/2;\n  var x = this.getX();\n  return {x: x, y: y};\n};\n\nSymbol.prototype.getRight = function() {\n  var y = this.getY() + this.group.getBBox().height/2;\n  var x = this.getX() + this.group.getBBox().width;\n  return {x: x, y: y};\n};\n\nSymbol.prototype.render = function() {\n  if (this.next) {\n\n    var self = this;\n    var lineLength = this.getAttr('line-length');\n\n    if (this.next_direction === 'right') {\n\n      var rightPoint = this.getRight();\n\n      if (!this.next.isPositioned) {\n        this.next.setY(rightPoint.y - this.next.height/2);\n        this.next.shiftX(this.group.getBBox().x + this.width + lineLength);\n\n        (function shift() {\n          var hasSymbolUnder = false;\n          var symb;\n          for (var i = 0, len = self.chart.symbols.length; i < len; i++) {\n            symb = self.chart.symbols[i];\n\n            var diff = Math.abs(symb.getCenter().x - self.next.getCenter().x);\n            if (symb.getCenter().y > self.next.getCenter().y && diff <= self.next.width/2) {\n              hasSymbolUnder = true;\n              break;\n            }\n          }\n\n          if (hasSymbolUnder) {\n            if (self.next.symbolType === 'end') return;\n            self.next.setX(symb.getX() + symb.width + lineLength);\n            shift();\n          }\n        })();\n\n        this.next.isPositioned = true;\n\n        this.next.render();\n      }\n    } else if (this.next_direction === 'left') {\n\n      var leftPoint = this.getLeft();\n\n      if (!this.next.isPositioned) {\n        this.next.setY(leftPoint.y - this.next.height/2);\n        this.next.shiftX(-(this.group.getBBox().x + this.width + lineLength));\n\n        (function shift() {\n          var hasSymbolUnder = false;\n          var symb;\n          for (var i = 0, len = self.chart.symbols.length; i < len; i++) {\n            symb = self.chart.symbols[i];\n\n            var diff = Math.abs(symb.getCenter().x - self.next.getCenter().x);\n            if (symb.getCenter().y > self.next.getCenter().y && diff <= self.next.width/2) {\n              hasSymbolUnder = true;\n              break;\n            }\n          }\n\n          if (hasSymbolUnder) {\n            if (self.next.symbolType === 'end') return;\n            self.next.setX(symb.getX() + symb.width + lineLength);\n            shift();\n          }\n        })();\n\n        this.next.isPositioned = true;\n\n        this.next.render();\n      }\n    } else {\n      var bottomPoint = this.getBottom();\n\n      if (!this.next.isPositioned) {\n        this.next.shiftY(this.getY() + this.height + lineLength);\n        this.next.setX(bottomPoint.x - this.next.width/2);\n        this.next.isPositioned = true;\n\n        this.next.render();\n      }\n    }\n  }\n};\n\nSymbol.prototype.renderLines = function() {\n  if (this.next) {\n    if (this.next_direction) {\n      this.drawLineTo(this.next, this.getAttr('arrow-text') || '', this.next_direction);\n    } else {\n      this.drawLineTo(this.next, this.getAttr('arrow-text') || '');\n    }\n  }\n};\n\nSymbol.prototype.drawLineTo = function(symbol, text, origin) {\n  if (this.connectedTo.indexOf(symbol) < 0) {\n    this.connectedTo.push(symbol);\n  }\n\n  var x = this.getCenter().x,\n      y = this.getCenter().y,\n      right = this.getRight(),\n      bottom = this.getBottom(),\n      top = this.getTop(),\n      left = this.getLeft();\n\n  var symbolX = symbol.getCenter().x,\n      symbolY = symbol.getCenter().y,\n      symbolTop = symbol.getTop(),\n      symbolRight = symbol.getRight(),\n      symbolLeft = symbol.getLeft();\n\n  var isOnSameColumn = x === symbolX,\n      isOnSameLine = y === symbolY,\n      isUnder = y < symbolY,\n      isUpper = y > symbolY || this === symbol,\n      isLeft = x > symbolX,\n      isRight = x < symbolX;\n\n  var maxX = 0,\n      line,\n      yOffset,\n      lineLength = this.getAttr('line-length'),\n      lineWith = this.getAttr('line-width');\n\n  if ((!origin || origin === 'bottom') && isOnSameColumn && isUnder) {\n    if (symbol.topLines.length === 0 && this.bottomLines.length === 0) {\n      line = drawLine(this.chart, bottom, symbolTop, text);\n    } else {\n      yOffset = Math.max(symbol.topLines.length, this.bottomLines.length) * 10;\n      line = drawLine(this.chart, bottom, [\n        {x: symbolTop.x, y: symbolTop.y - yOffset},\n        {x: symbolTop.x, y: symbolTop.y}\n      ], text);\n    }\n    this.bottomLines.push(line);\n    symbol.topLines.push(line);\n    this.bottomStart = true;\n    symbol.topEnd = true;\n    maxX = bottom.x;\n  } else if ((!origin || origin === 'right') && isOnSameLine && isRight) {\n    if (symbol.leftLines.length === 0 && this.rightLines.length === 0) {\n      line = drawLine(this.chart, right, symbolLeft, text);\n    } else {\n      yOffset = Math.max(symbol.leftLines.length, this.rightLines.length) * 10;\n      line = drawLine(this.chart, right, [\n        {x: right.x, y: right.y - yOffset},\n        {x: right.x, y: symbolLeft.y - yOffset},\n        {x: symbolLeft.x, y: symbolLeft.y - yOffset},\n        {x: symbolLeft.x, y: symbolLeft.y}\n      ], text);\n    }\n    this.rightLines.push(line);\n    symbol.leftLines.push(line);\n    this.rightStart = true;\n    symbol.leftEnd = true;\n    maxX = symbolLeft.x;\n  } else if ((!origin || origin === 'left') && isOnSameLine && isLeft) {\n    if (symbol.rightLines.length === 0 && this.leftLines.length === 0) {\n      line = drawLine(this.chart, left, symbolRight, text);\n    } else {\n      yOffset = Math.max(symbol.rightLines.length, this.leftLines.length) * 10;\n      line = drawLine(this.chart, right, [\n        {x: right.x, y: right.y - yOffset},\n        {x: right.x, y: symbolRight.y - yOffset},\n        {x: symbolRight.x, y: symbolRight.y - yOffset},\n        {x: symbolRight.x, y: symbolRight.y}\n      ], text);\n    }\n    this.leftLines.push(line);\n    symbol.rightLines.push(line);\n    this.leftStart = true;\n    symbol.rightEnd = true;\n    maxX = symbolRight.x;\n  } else if ((!origin || origin === 'right') && isOnSameColumn && isUpper) {\n    yOffset = Math.max(symbol.topLines.length, this.rightLines.length) * 10;\n    line = drawLine(this.chart, right, [\n      {x: right.x + lineLength/2, y: right.y - yOffset},\n      {x: right.x + lineLength/2, y: symbolTop.y - lineLength/2 - yOffset},\n      {x: symbolTop.x, y: symbolTop.y - lineLength/2 - yOffset},\n      {x: symbolTop.x, y: symbolTop.y}\n    ], text);\n    this.rightLines.push(line);\n    symbol.topLines.push(line);\n    this.rightStart = true;\n    symbol.topEnd = true;\n    maxX = right.x + lineLength/2;\n  } else if ((!origin || origin === 'right') && isOnSameColumn && isUnder) {\n    yOffset = Math.max(symbol.topLines.length, this.rightLines.length) * 10;\n    line = drawLine(this.chart, right, [\n      {x: right.x + lineLength/2, y: right.y - yOffset},\n      {x: right.x + lineLength/2, y: symbolTop.y - lineLength/2 - yOffset},\n      {x: symbolTop.x, y: symbolTop.y - lineLength/2 - yOffset},\n      {x: symbolTop.x, y: symbolTop.y}\n    ], text);\n    this.rightLines.push(line);\n    symbol.topLines.push(line);\n    this.rightStart = true;\n    symbol.topEnd = true;\n    maxX = right.x + lineLength/2;\n  } else if ((!origin || origin === 'bottom') && isLeft) {\n    yOffset = Math.max(symbol.topLines.length, this.bottomLines.length) * 10;\n    if (this.leftEnd && isUpper) {\n      line = drawLine(this.chart, bottom, [\n        {x: bottom.x, y: bottom.y + lineLength/2 - yOffset},\n        {x: bottom.x + (bottom.x - symbolTop.x)/2, y: bottom.y + lineLength/2 - yOffset},\n        {x: bottom.x + (bottom.x - symbolTop.x)/2, y: symbolTop.y - lineLength/2 - yOffset},\n        {x: symbolTop.x, y: symbolTop.y - lineLength/2 - yOffset},\n        {x: symbolTop.x, y: symbolTop.y}\n      ], text);\n    } else {\n      line = drawLine(this.chart, bottom, [\n        {x: bottom.x, y: symbolTop.y - lineLength/2 - yOffset},\n        {x: symbolTop.x, y: symbolTop.y - lineLength/2 - yOffset},\n        {x: symbolTop.x, y: symbolTop.y}\n      ], text);\n    }\n    this.bottomLines.push(line);\n    symbol.topLines.push(line);\n    this.bottomStart = true;\n    symbol.topEnd = true;\n    maxX = bottom.x + (bottom.x - symbolTop.x)/2;\n  } else if ((!origin || origin === 'bottom') && isRight && isUnder) {\n    yOffset = Math.max(symbol.topLines.length, this.bottomLines.length) * 10;\n    line = drawLine(this.chart, bottom, [\n      {x: bottom.x, y: symbolTop.y - lineLength/2 - yOffset},\n      {x: symbolTop.x, y: symbolTop.y - lineLength/2 - yOffset},\n      {x: symbolTop.x, y: symbolTop.y}\n    ], text);\n    this.bottomLines.push(line);\n    symbol.topLines.push(line);\n    this.bottomStart = true;\n    symbol.topEnd = true;\n    maxX = bottom.x;\n    if (symbolTop.x > maxX) maxX = symbolTop.x;\n  } else if ((!origin || origin === 'bottom') && isRight) {\n    yOffset = Math.max(symbol.topLines.length, this.bottomLines.length) * 10;\n    line = drawLine(this.chart, bottom, [\n      {x: bottom.x, y: bottom.y + lineLength/2 - yOffset},\n      {x: bottom.x + (bottom.x - symbolTop.x)/2, y: bottom.y + lineLength/2 - yOffset},\n      {x: bottom.x + (bottom.x - symbolTop.x)/2, y: symbolTop.y - lineLength/2 - yOffset},\n      {x: symbolTop.x, y: symbolTop.y - lineLength/2 - yOffset},\n      {x: symbolTop.x, y: symbolTop.y}\n    ], text);\n    this.bottomLines.push(line);\n    symbol.topLines.push(line);\n    this.bottomStart = true;\n    symbol.topEnd = true;\n    maxX = bottom.x + (bottom.x - symbolTop.x)/2;\n  } else if ((origin && origin === 'right') && isLeft) {\n    yOffset = Math.max(symbol.topLines.length, this.rightLines.length) * 10;\n    line = drawLine(this.chart, right, [\n      {x: right.x + lineLength/2, y: right.y},\n      {x: right.x + lineLength/2, y: symbolTop.y - lineLength/2 - yOffset},\n      {x: symbolTop.x, y: symbolTop.y - lineLength/2 - yOffset},\n      {x: symbolTop.x, y: symbolTop.y}\n    ], text);\n    this.rightLines.push(line);\n    symbol.topLines.push(line);\n    this.rightStart = true;\n    symbol.topEnd = true;\n    maxX = right.x + lineLength/2;\n  } else if ((origin && origin === 'right') && isRight) {\n    yOffset = Math.max(symbol.topLines.length, this.rightLines.length) * 10;\n    line = drawLine(this.chart, right, [\n      {x: symbolTop.x, y: right.y - yOffset},\n      {x: symbolTop.x, y: symbolTop.y - yOffset}\n    ], text);\n    this.rightLines.push(line);\n    symbol.topLines.push(line);\n    this.rightStart = true;\n    symbol.topEnd = true;\n    maxX = right.x + lineLength/2;\n  } else if ((origin && origin === 'bottom') && isOnSameColumn && isUpper) {\n    yOffset = Math.max(symbol.topLines.length, this.bottomLines.length) * 10;\n    line = drawLine(this.chart, bottom, [\n      {x: bottom.x, y: bottom.y + lineLength/2 - yOffset},\n      {x: right.x + lineLength/2, y: bottom.y + lineLength/2 - yOffset},\n      {x: right.x + lineLength/2, y: symbolTop.y - lineLength/2 - yOffset},\n      {x: symbolTop.x, y: symbolTop.y - lineLength/2 - yOffset},\n      {x: symbolTop.x, y: symbolTop.y}\n    ], text);\n    this.bottomLines.push(line);\n    symbol.topLines.push(line);\n    this.bottomStart = true;\n    symbol.topEnd = true;\n    maxX = bottom.x + lineLength/2;\n  } else if ((origin === 'left') && isOnSameColumn && isUpper) {\n    var diffX = left.x - lineLength/2;\n    if (symbolLeft.x < left.x) {\n      diffX = symbolLeft.x - lineLength/2;\n    }\n    yOffset = Math.max(symbol.topLines.length, this.leftLines.length) * 10;\n    line = drawLine(this.chart, left, [\n      {x: diffX, y: left.y - yOffset},\n      {x: diffX, y: symbolTop.y - lineLength/2 - yOffset},\n      {x: symbolTop.x, y: symbolTop.y - lineLength/2 - yOffset},\n      {x: symbolTop.x, y: symbolTop.y}\n    ], text);\n    this.leftLines.push(line);\n    symbol.topLines.push(line);\n    this.leftStart = true;\n    symbol.topEnd = true;\n    maxX = left.x;\n  } else if ((origin === 'left')) {\n    yOffset = Math.max(symbol.topLines.length, this.leftLines.length) * 10;\n    line = drawLine(this.chart, left, [\n      {x: symbolTop.x + (left.x - symbolTop.x)/2, y: left.y},\n      {x: symbolTop.x + (left.x - symbolTop.x)/2, y: symbolTop.y - lineLength/2 - yOffset},\n      {x: symbolTop.x, y: symbolTop.y - lineLength/2 - yOffset},\n      {x: symbolTop.x, y: symbolTop.y}\n    ], text);\n    this.leftLines.push(line);\n    symbol.topLines.push(line);\n    this.leftStart = true;\n    symbol.topEnd = true;\n    maxX = left.x;\n  } else if ((origin === 'top')) {\n    yOffset = Math.max(symbol.topLines.length, this.topLines.length) * 10;\n    line = drawLine(this.chart, top, [\n      {x: top.x, y: symbolTop.y - lineLength/2 - yOffset},\n      {x: symbolTop.x, y: symbolTop.y - lineLength/2 - yOffset},\n      {x: symbolTop.x, y: symbolTop.y}\n    ], text);\n    this.topLines.push(line);\n    symbol.topLines.push(line);\n    this.topStart = true;\n    symbol.topEnd = true;\n    maxX = top.x;\n  }\n\n  //update line style\n  if (this.lineStyle[symbol.key] && line){\n    line.attr(this.lineStyle[symbol.key]);\n  }\n\n  if (line) {\n    for (var l = 0, llen = this.chart.lines.length; l < llen; l++) {\n      var otherLine = this.chart.lines[l];\n\n      var ePath = otherLine.attr('path'),\n          lPath = line.attr('path');\n\n      for (var iP = 0, lenP = ePath.length - 1; iP < lenP; iP++) {\n        var newPath = [];\n        newPath.push(['M', ePath[iP][1], ePath[iP][2]]);\n        newPath.push(['L', ePath[iP + 1][1], ePath[iP + 1][2]]);\n\n        var line1_from_x = newPath[0][1];\n        var line1_from_y = newPath[0][2];\n        var line1_to_x = newPath[1][1];\n        var line1_to_y = newPath[1][2];\n\n        for (var lP = 0, lenlP = lPath.length - 1; lP < lenlP; lP++) {\n          var newLinePath = [];\n          newLinePath.push(['M', lPath[lP][1], lPath[lP][2]]);\n          newLinePath.push(['L', lPath[lP + 1][1], lPath[lP + 1][2]]);\n\n          var line2_from_x = newLinePath[0][1];\n          var line2_from_y = newLinePath[0][2];\n          var line2_to_x = newLinePath[1][1];\n          var line2_to_y = newLinePath[1][2];\n\n          var res = checkLineIntersection(line1_from_x, line1_from_y, line1_to_x, line1_to_y, line2_from_x, line2_from_y, line2_to_x, line2_to_y);\n          if (res.onLine1 && res.onLine2) {\n\n            var newSegment;\n            if (line2_from_y === line2_to_y) {\n              if (line2_from_x > line2_to_x) {\n                newSegment = ['L', res.x + lineWith * 2,  line2_from_y];\n                lPath.splice(lP + 1, 0, newSegment);\n                newSegment = ['C', res.x + lineWith * 2,  line2_from_y, res.x, line2_from_y - lineWith * 4, res.x - lineWith * 2, line2_from_y];\n                lPath.splice(lP + 2, 0, newSegment);\n                line.attr('path', lPath);\n              } else {\n                newSegment = ['L', res.x - lineWith * 2,  line2_from_y];\n                lPath.splice(lP + 1, 0, newSegment);\n                newSegment = ['C', res.x - lineWith * 2,  line2_from_y, res.x, line2_from_y - lineWith * 4, res.x + lineWith * 2, line2_from_y];\n                lPath.splice(lP + 2, 0, newSegment);\n                line.attr('path', lPath);\n              }\n            } else {\n              if (line2_from_y > line2_to_y) {\n                newSegment = ['L', line2_from_x, res.y + lineWith * 2];\n                lPath.splice(lP + 1, 0, newSegment);\n                newSegment = ['C', line2_from_x, res.y + lineWith * 2, line2_from_x + lineWith * 4, res.y, line2_from_x, res.y - lineWith * 2];\n                lPath.splice(lP + 2, 0, newSegment);\n                line.attr('path', lPath);\n              } else {\n                newSegment = ['L', line2_from_x, res.y - lineWith * 2];\n                lPath.splice(lP + 1, 0, newSegment);\n                newSegment = ['C', line2_from_x, res.y - lineWith * 2, line2_from_x + lineWith * 4, res.y, line2_from_x, res.y + lineWith * 2];\n                lPath.splice(lP + 2, 0, newSegment);\n                line.attr('path', lPath);\n              }\n            }\n\n            lP += 2;\n          }\n        }\n      }\n    }\n\n    this.chart.lines.push(line);\n    if (this.chart.minXFromSymbols === undefined || this.chart.minXFromSymbols > left.x) {\n      this.chart.minXFromSymbols = left.x;\n    }\n  }\n\n  if (!this.chart.maxXFromLine || (this.chart.maxXFromLine && maxX > this.chart.maxXFromLine)) {\n    this.chart.maxXFromLine = maxX;\n  }\n};\n\nmodule.exports = Symbol;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/flowchart.symbol.js\n// module id = 2\n// module chunks = 0","function drawPath(chart, location, points) {\n  var i, len;\n  var path = 'M{0},{1}';\n  for (i = 2, len = 2 * points.length + 2; i < len; i+=2) {\n    path += ' L{' + i + '},{' + (i + 1) + '}';\n  }\n  var pathValues = [location.x, location.y];\n  for (i = 0, len = points.length; i < len; i++) {\n    pathValues.push(points[i].x);\n    pathValues.push(points[i].y);\n  }\n  var symbol = chart.paper.path(path, pathValues);\n  symbol.attr('stroke', chart.options['element-color']);\n  symbol.attr('stroke-width', chart.options['line-width']);\n\n  var font = chart.options.font;\n  var fontF = chart.options['font-family'];\n  var fontW = chart.options['font-weight'];\n\n  if (font) symbol.attr({ 'font': font });\n  if (fontF) symbol.attr({ 'font-family': fontF });\n  if (fontW) symbol.attr({ 'font-weight': fontW });\n\n  return symbol;\n}\n\nfunction drawLine(chart, from, to, text) {\n  var i, len;\n\n  if (Object.prototype.toString.call(to) !== '[object Array]') {\n    to = [to];\n  }\n\n  var path = 'M{0},{1}';\n  for (i = 2, len = 2 * to.length + 2; i < len; i+=2) {\n    path += ' L{' + i + '},{' + (i + 1) + '}';\n  }\n  var pathValues = [from.x, from.y];\n  for (i = 0, len = to.length; i < len; i++) {\n    pathValues.push(to[i].x);\n    pathValues.push(to[i].y);\n  }\n\n  var line = chart.paper.path(path, pathValues);\n  line.attr({\n    stroke: chart.options['line-color'],\n    'stroke-width': chart.options['line-width'],\n    'arrow-end': chart.options['arrow-end']\n  });\n\n  var font = chart.options.font;\n  var fontF = chart.options['font-family'];\n  var fontW = chart.options['font-weight'];\n\n  if (font) line.attr({ 'font': font });\n  if (fontF) line.attr({ 'font-family': fontF });\n  if (fontW) line.attr({ 'font-weight': fontW });\n\n  if (text) {\n\n    var centerText = false;\n\n    var textPath = chart.paper.text(0, 0, text);\n    var textAnchor = 'start';\n\n    var isHorizontal = false;\n    var firstTo = to[0];\n\n    if (from.y === firstTo.y) {\n      isHorizontal = true;\n    }\n\n    var x = 0,\n        y = 0;\n\n    if (centerText) {\n      if (from.x > firstTo.x) {\n        x = from.x - (from.x - firstTo.x)/2;\n      } else {\n        x = firstTo.x - (firstTo.x - from.x)/2;\n      }\n\n      if (from.y > firstTo.y) {\n        y = from.y - (from.y - firstTo.y)/2;\n      } else {\n        y = firstTo.y - (firstTo.y - from.y)/2;\n      }\n\n      if (isHorizontal) {\n        x -= textPath.getBBox().width/2;\n        y -= chart.options['text-margin'];\n      } else {\n        x += chart.options['text-margin'];\n        y -= textPath.getBBox().height/2;\n      }\n    } else {\n      x = from.x;\n      y = from.y;\n\n      if (isHorizontal) {\n        if (from.x > firstTo.x) {\n          x -= chart.options['text-margin']/2;\n          textAnchor = 'end';\n        } else {\n          x += chart.options['text-margin']/2;\n        }\n        y -= chart.options['text-margin'];\n      } else {\n        x += chart.options['text-margin']/2;\n        y += chart.options['text-margin'];\n        if (from.y > firstTo.y) {\n          y -= chart.options['text-margin']*2;\n        }\n      }\n    }\n\n    textPath.attr({\n      'text-anchor': textAnchor,\n      'font-size': chart.options['font-size'],\n      'fill': chart.options['font-color'],\n      x: x,\n      y: y\n    });\n\n    if (font) textPath.attr({ 'font': font });\n    if (fontF) textPath.attr({ 'font-family': fontF });\n    if (fontW) textPath.attr({ 'font-weight': fontW });\n  }\n\n  return line;\n}\n\nfunction checkLineIntersection(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {\n  // if the lines intersect, the result contains the x and y of the intersection (treating the lines as infinite) and booleans for whether line segment 1 or line segment 2 contain the point\n  var denominator, a, b, numerator1, numerator2, result = {\n    x: null,\n    y: null,\n    onLine1: false,\n    onLine2: false\n  };\n  denominator = ((line2EndY - line2StartY) * (line1EndX - line1StartX)) - ((line2EndX - line2StartX) * (line1EndY - line1StartY));\n  if (denominator === 0) {\n    return result;\n  }\n  a = line1StartY - line2StartY;\n  b = line1StartX - line2StartX;\n  numerator1 = ((line2EndX - line2StartX) * a) - ((line2EndY - line2StartY) * b);\n  numerator2 = ((line1EndX - line1StartX) * a) - ((line1EndY - line1StartY) * b);\n  a = numerator1 / denominator;\n  b = numerator2 / denominator;\n\n  // if we cast these lines infinitely in both directions, they intersect here:\n  result.x = line1StartX + (a * (line1EndX - line1StartX));\n  result.y = line1StartY + (a * (line1EndY - line1StartY));\n  /*\n  // it is worth noting that this should be the same as:\n  x = line2StartX + (b * (line2EndX - line2StartX));\n  y = line2StartX + (b * (line2EndY - line2StartY));\n  */\n  // if line1 is a segment and line2 is infinite, they intersect if:\n  if (a > 0 && a < 1) {\n    result.onLine1 = true;\n  }\n  // if line2 is a segment and line1 is infinite, they intersect if:\n  if (b > 0 && b < 1) {\n    result.onLine2 = true;\n  }\n  // if line1 and line2 are segments, they intersect if both of the above are true\n  return result;\n}\n\nmodule.exports = {\n\tdrawPath: drawPath,\n\tdrawLine: drawLine,\n\tcheckLineIntersection: checkLineIntersection\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/flowchart.functions.js\n// module id = 3\n// module chunks = 0","var FlowChart = require('./flowchart.chart');\nvar Start = require('./flowchart.symbol.start');\nvar End = require('./flowchart.symbol.end');\nvar Operation = require('./flowchart.symbol.operation');\nvar InputOutput = require('./flowchart.symbol.inputoutput');\nvar Input = require('./flowchart.symbol.input'); //tds\nvar Output = require('./flowchart.symbol.output'); //tds\nvar Subroutine = require('./flowchart.symbol.subroutine');\nvar Condition = require('./flowchart.symbol.condition');\nvar Parallel = require('./flowchart.symbol.parallel');\n\n\nfunction parse(input) {\n  input = input || '';\n  input = input.trim();\n\n  var chart = {\n    symbols: {},\n    start: null,\n    drawSVG: function(container, options) {\n      var self = this;\n\n      if (this.diagram) {\n        this.diagram.clean();\n      }\n\n      var diagram = new FlowChart(container, options);\n      this.diagram = diagram;\n      var dispSymbols = {};\n\n      function getDisplaySymbol(s) {\n        if (dispSymbols[s.key]) {\n          return dispSymbols[s.key];\n        }\n\n        switch (s.symbolType) {\n          case 'start':\n            dispSymbols[s.key] = new Start(diagram, s);\n            break;\n          case 'end':\n            dispSymbols[s.key] = new End(diagram, s);\n            break;\n          case 'operation':\n            dispSymbols[s.key] = new Operation(diagram, s);\n            break;\n          case 'inputoutput':\n            dispSymbols[s.key] = new InputOutput(diagram, s);\n            break;\n          case 'input':\n            dispSymbols[s.key] = new Input(diagram, s); //tds\n            break;         \n          case 'output':\n            dispSymbols[s.key] = new Output(diagram, s); //tds\n            break;          \n          case 'subroutine':\n            dispSymbols[s.key] = new Subroutine(diagram, s);\n            break;\n          case 'condition':\n            dispSymbols[s.key] = new Condition(diagram, s);\n            break;\n          case 'parallel':\n            dispSymbols[s.key] = new Parallel(diagram, s);\n            break;\n          default:\n            return new Error('Wrong symbol type!');\n        }\n\n        return dispSymbols[s.key];\n      }\n\n      (function constructChart(s, prevDisp, prev) {\n        var dispSymb = getDisplaySymbol(s);\n\n        if (self.start === s) {\n          diagram.startWith(dispSymb);\n        } else if (prevDisp && prev && !prevDisp.pathOk) {\n          if (prevDisp instanceof(Condition)) {\n            if (prev.yes === s) {\n              prevDisp.yes(dispSymb);\n            }\n            if (prev.no === s) {\n              prevDisp.no(dispSymb);\n            }\n          } else if (prevDisp instanceof(Parallel)) {\n            if (prev.path1 === s) {\n              prevDisp.path1(dispSymb);\n            }\n            if (prev.path2 === s) {\n              prevDisp.path2(dispSymb);\n            }\n            if (prev.path3 === s) {\n              prevDisp.path3(dispSymb);\n            }\n          } else {\n            prevDisp.then(dispSymb);\n          }\n        }\n\n        if (dispSymb.pathOk) {\n          return dispSymb;\n        }\n\n        if (dispSymb instanceof(Condition)) {\n          if (s.yes) {\n            constructChart(s.yes, dispSymb, s);\n          }\n          if (s.no) {\n            constructChart(s.no, dispSymb, s);\n          }\n        } else if (dispSymb instanceof(Parallel)) {\n          if (s.path1) {\n            constructChart(s.path1, dispSymb, s);\n          }\n          if (s.path2) {\n            constructChart(s.path2, dispSymb, s);\n          }\n          if (s.path3) {\n            constructChart(s.path3, dispSymb, s);\n          }\n        } else if (s.next) {\n          constructChart(s.next, dispSymb, s);\n        }\n\n        return dispSymb;\n      })(this.start);\n\n      diagram.render();\n    },\n    clean: function() {\n      this.diagram.clean();\n    },\n    options: function() {\n      return this.diagram.options;\n    }\n  };\n\n  var lines = [];\n  var prevBreak = 0;\n  for (var i0 = 1, i0len = input.length; i0 < i0len; i0++) {\n    if(input[i0] === '\\n' && input[i0 - 1] !== '\\\\') {\n      var line0 = input.substring(prevBreak, i0);\n      prevBreak = i0 + 1;\n      lines.push(line0.replace(/\\\\\\n/g, '\\n'));\n    }\n  }\n\n  if (prevBreak < input.length) {\n    lines.push(input.substr(prevBreak));\n  }\n\n  for (var l = 1, len = lines.length; l < len;) {\n    var currentLine = lines[l];\n\n    if (currentLine.indexOf('->') < 0 && currentLine.indexOf('=>') < 0 && currentLine.indexOf('@>') < 0) {\n      lines[l - 1] += '\\n' + currentLine;\n      lines.splice(l, 1);\n      len--;\n    } else {\n      l++;\n    }\n  }\n\n  function getStyle(s){\n    var startIndex = s.indexOf('(') + 1;\n    var endIndex = s.indexOf(')');\n    if (startIndex >= 0 && endIndex >= 0) {\n      return s.substring(startIndex,endIndex);\n    }\n    return '{}';\n  }\n\n  function getSymbValue(s){\n    var startIndex = s.indexOf('(') + 1;\n    var endIndex = s.indexOf(')');\n    if (startIndex >= 0 && endIndex >= 0) {\n      return s.substring(startIndex,endIndex);\n    }\n    return '';\n  }\n\n  function getSymbol(s) {\n    var startIndex = s.indexOf('(') + 1;\n    var endIndex = s.indexOf(')');\n    if (startIndex >= 0 && endIndex >= 0) {\n      return chart.symbols[s.substring(0, startIndex - 1)];\n    }\n    return chart.symbols[s];\n  }\n\n  function getNextPath(s) {\n    var next = 'next';\n    var startIndex = s.indexOf('(') + 1;\n    var endIndex = s.indexOf(')');\n    if (startIndex >= 0 && endIndex >= 0) {\n      next = flowSymb.substring(startIndex, endIndex);\n      if (next.indexOf(',') < 0) {\n        if (next !== 'yes' && next !== 'no') {\n          next = 'next, ' + next;\n        }\n      }\n    }\n    return next;\n  }\n  \n  function getAnnotation(s) {\n\tvar startIndex = s.indexOf(\"(\") + 1, endIndex = s.indexOf(\")\");\n\tvar tmp = s.substring(startIndex, endIndex);\n\tif(tmp.indexOf(\",\") > 0) { tmp = tmp.substring(0, tmp.indexOf(\",\")); }\n\tvar tmp_split = tmp.split(\"@\");\n\tif(tmp_split.length > 1)\n\t\treturn startIndex >= 0 && endIndex >= 0 ? tmp_split[1] : \"\";\n  }\n\n  while (lines.length > 0) {\n    var line = lines.splice(0, 1)[0].trim();\n\n    if (line.indexOf('=>') >= 0) {\n      // definition\n      var parts = line.split('=>');\n      var symbol = {\n        key: parts[0].replace(/\\(.*\\)/, ''),\n        symbolType: parts[1],\n        text: null,\n        link: null,\n        target: null,\n        flowstate: null,\n        function: null,\n        lineStyle: {},\n        params: {}\n      };\n\n      //parse parameters\n      var params = parts[0].match(/\\((.*)\\)/);\n      if (params && params.length > 1){\n        var entries = params[1].split(',');\n        for(var i = 0; i < entries.length; i++) {\n          var entry = entries[i].split('=');\n          if (entry.length == 2) {\n            symbol.params[entry[0]] = entry[1];\n          }\n        }\n      }\n\n      var sub;\n\n      if (symbol.symbolType.indexOf(': ') >= 0) {\n        sub = symbol.symbolType.split(': ');\n        symbol.symbolType = sub.shift();\n        symbol.text = sub.join(': ');\n      }\n\n      if (symbol.text && symbol.text.indexOf(':$') >= 0) {\n        sub = symbol.text.split(':$');\n        symbol.text = sub.shift();\n        symbol.function = sub.join(':$');\n      } else if (symbol.symbolType.indexOf(':$') >= 0) {\n        sub = symbol.symbolType.split(':$');\n        symbol.symbolType = sub.shift();\n        symbol.function = sub.join(':$');\n      } else if (symbol.text && symbol.text.indexOf(':>') >= 0) {\n        sub = symbol.text.split(':>');\n        symbol.text = sub.shift();\n        symbol.link = sub.join(':>');\n      } else if (symbol.symbolType.indexOf(':>') >= 0) {\n        sub = symbol.symbolType.split(':>');\n        symbol.symbolType = sub.shift();\n        symbol.link = sub.join(':>');\n      }\n\n      if (symbol.symbolType.indexOf('\\n') >= 0) {\n        symbol.symbolType = symbol.symbolType.split('\\n')[0];\n      }\n\n      /* adding support for links */\n      if (symbol.link) {\n        var startIndex = symbol.link.indexOf('[') + 1;\n        var endIndex = symbol.link.indexOf(']');\n        if (startIndex >= 0 && endIndex >= 0) {\n          symbol.target = symbol.link.substring(startIndex, endIndex);\n          symbol.link = symbol.link.substring(0, startIndex - 1);\n        }\n      }\n      /* end of link support */\n\n      /* adding support for flowstates */\n      if (symbol.text) {\n        if (symbol.text.indexOf('|') >= 0) {\n          var txtAndState = symbol.text.split('|');\n          symbol.flowstate = txtAndState.pop().trim();\n          symbol.text = txtAndState.join('|');\n        }\n      }\n      /* end of flowstate support */\n\n      chart.symbols[symbol.key] = symbol;\n\n    } else if (line.indexOf('->') >= 0) {\n      var ann = getAnnotation(line);\n      if (ann) {\n        line = line.replace('@' + ann, ''); \n      }\n      // flow\n      var flowSymbols = line.split('->');\n      for (var iS = 0, lenS = flowSymbols.length; iS < lenS; iS++) {\n        var flowSymb = flowSymbols[iS];\n        var symbVal = getSymbValue(flowSymb);\n\n        if (symbVal === 'true' || symbVal === 'false') {\n          // map true or false to yes or no respectively\n          flowSymb = flowSymb.replace('true', 'yes');\n          flowSymb = flowSymb.replace('false', 'no');\n        }\n        \n        var next = getNextPath(flowSymb);\n        var realSymb = getSymbol(flowSymb);\n\n        var direction = null;\n        if (next.indexOf(',') >= 0) {\n          var condOpt = next.split(',');\n          next = condOpt[0];\n          direction = condOpt[1].trim();\n        }\n\n        if (ann) {\n          if (realSymb.symbolType === 'condition') {\n            if (next === \"yes\" || next === \"true\") {\n              realSymb.yes_annotation = ann;\n            } else {\n              realSymb.no_annotation = ann;\n            }\n          } else if (realSymb.symbolType === 'parallel') {\n            if (next === 'path1') {\n              realSymb.path1_annotation = ann;\n            } else if (next === 'path2') {\n              realSymb.path2_annotation = ann;\n            } else if (next === 'path3') {\n              realSymb.path3_annotation = ann;\n            }\n          }\n          ann = null;\n        }\n\n        if (!chart.start) {\n          chart.start = realSymb;\n        }\n\n        if (iS + 1 < lenS) {\n          var nextSymb = flowSymbols[iS + 1];\n          realSymb[next] = getSymbol(nextSymb);\n          realSymb['direction_' + next] = direction;\n          direction = null;\n        }\n      }\n    } else if (line.indexOf('@>') >= 0) {\n\n      // line style\n      var lineStyleSymbols = line.split('@>');\n      for (var iSS = 0, lenSS = lineStyleSymbols.length; iSS < lenSS; iSS++) {\n        if ((iSS + 1) !== lenSS) {\n          var curSymb = getSymbol(lineStyleSymbols[iSS]);\n          var nextSymbol = getSymbol(lineStyleSymbols[iSS+1]);\n\n          curSymb['lineStyle'][nextSymbol.key] = JSON.parse(getStyle(lineStyleSymbols[iSS + 1]));\n        }\n      }\n    }\n\n  }\n  return chart;\n}\n\nmodule.exports = parse;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/flowchart.parse.js\n// module id = 4\n// module chunks = 0","var Symbol = require('./flowchart.symbol');\nvar inherits = require('./flowchart.helpers').inherits;\nvar drawAPI = require('./flowchart.functions');\nvar drawPath = drawAPI.drawPath;\n\nfunction Condition(chart, options) {\n  options = options || {};\n  Symbol.call(this, chart, options);\n  this.yes_annotation = options.yes_annotation;\n  this.no_annotation = options.no_annotation;\n  this.textMargin = this.getAttr('text-margin');\n  this.yes_direction = options.direction_yes;\n  this.no_direction = options.direction_no;\n  if (!this.no_direction && this.yes_direction === 'right') {\n    this.no_direction = 'bottom';\n  } else if (!this.yes_direction && this.no_direction === 'bottom') {\n    this.yes_direction = 'right'\n  }\n  this.yes_direction = this.yes_direction || 'bottom';\n  this.no_direction = this.no_direction || 'right';\n\n  this.text.attr({\n    x: this.textMargin * 2\n  });\n\n  var width = this.text.getBBox().width + 3 * this.textMargin;\n  width += width/2;\n  var height = this.text.getBBox().height + 2 * this.textMargin;\n  height += height/2;\n  height = Math.max(width * 0.5, height);\n  var startX = width/4;\n  var startY = height/4;\n\n  this.text.attr({\n    x: startX + this.textMargin/2\n  });\n\n  var start = {x: startX, y: startY};\n  var points = [\n    {x: startX - width/4, y: startY + height/4},\n    {x: startX - width/4 + width/2, y: startY + height/4 + height/2},\n    {x: startX - width/4 + width, y: startY + height/4},\n    {x: startX - width/4 + width/2, y: startY + height/4 - height/2},\n    {x: startX - width/4, y: startY + height/4}\n  ];\n\n  var symbol = drawPath(chart, start, points);\n\n  symbol.attr({\n    stroke: this.getAttr('element-color'),\n    'stroke-width': this.getAttr('line-width'),\n    fill: this.getAttr('fill')\n  });\n  if (options.link) { symbol.attr('href', options.link); }\n  if (options.target) { symbol.attr('target', options.target); }\n  if (options.key) { symbol.node.id = options.key; }\n  symbol.node.setAttribute('class', this.getAttr('class'));\n\n  this.text.attr({\n    y: symbol.getBBox().height/2\n  });\n\n  this.group.push(symbol);\n  symbol.insertBefore(this.text);\n  this.symbol = symbol\n\n  this.initialize();\n}\ninherits(Condition, Symbol);\n\nCondition.prototype.render = function() {\n  var self = this;\n  if (this.yes_direction) {\n    this[this.yes_direction + '_symbol'] = this.yes_symbol;\n  }\n\n  if (this.no_direction) {\n    this[this.no_direction + '_symbol'] = this.no_symbol;\n  }\n\n  var lineLength = this.getAttr('line-length');\n\n  if (this.bottom_symbol) {\n    var bottomPoint = this.getBottom();\n\n    if (!this.bottom_symbol.isPositioned) {\n      this.bottom_symbol.shiftY(this.getY() + this.height + lineLength);\n      this.bottom_symbol.setX(bottomPoint.x - this.bottom_symbol.width/2);\n      this.bottom_symbol.isPositioned = true;\n\n      this.bottom_symbol.render();\n    }\n  }\n\n  if (this.right_symbol) {\n    var rightPoint = this.getRight();\n\n    if (!this.right_symbol.isPositioned) {\n\n      this.right_symbol.setY(rightPoint.y - this.right_symbol.height/2);\n      this.right_symbol.shiftX(this.group.getBBox().x + this.width + lineLength);\n\n      (function shift() {\n        var hasSymbolUnder = false;\n        var symb;\n        for (var i = 0, len = self.chart.symbols.length; i < len; i++) {\n          symb = self.chart.symbols[i];\n\n          if (!self.params['align-next'] || self.params['align-next'] !== 'no') { \n            var diff = Math.abs(symb.getCenter().x - self.right_symbol.getCenter().x);\n            if (symb.getCenter().y > self.right_symbol.getCenter().y && diff <= self.right_symbol.width/2) {\n              hasSymbolUnder = true;\n              break;\n            }\n          }\n        }\n\n        if (hasSymbolUnder) {\n          if (self.right_symbol.symbolType === 'end') return;\n          self.right_symbol.setX(symb.getX() + symb.width + lineLength);\n          shift();\n        }\n      })();\n\n      this.right_symbol.isPositioned = true;\n\n      this.right_symbol.render();\n    }\n  }\n  \n  if (this.left_symbol) {\n    var leftPoint = this.getLeft();\n  \n    if (!this.left_symbol.isPositioned) {\n      this.left_symbol.setY(leftPoint.y - this.left_symbol.height / 2);\n      this.left_symbol.shiftX(-(this.group.getBBox().x + this.width + lineLength));\n\n      (function shift() {\n        var hasSymbolUnder = false;\n        var symb;\n        for (var i = 0, len = self.chart.symbols.length; i < len; i++) {\n          symb = self.chart.symbols[i];\n    \n          if (!self.params['align-next'] || self.params['align-next'] !== 'no') {\n            var diff = Math.abs(symb.getCenter().x - self.left_symbol.getCenter().x);\n            if (symb.getCenter().y > self.left_symbol.getCenter().y && diff <= self.left_symbol.width / 2) {\n              hasSymbolUnder = true;\n              break;\n            }\n          }\n        }\n    \n        if (hasSymbolUnder) {\n          if (self.left_symbol.symbolType === 'end') return;\n          self.left_symbol.setX(symb.getX() + symb.width + lineLength);\n          shift();\n        }\n      })();\n  \n      this.left_symbol.isPositioned = true;\n  \n      this.left_symbol.render();\n    }\n  }\n};\n\nCondition.prototype.renderLines = function() {\n  if (this.yes_symbol) {\n    this.drawLineTo(this.yes_symbol, this.yes_annotation ? this.yes_annotation : this.getAttr('yes-text'), this.yes_direction);\n  }\n\n  if (this.no_symbol) {\n    this.drawLineTo(this.no_symbol, this.no_annotation ? this.no_annotation : this.getAttr('no-text'), this.no_direction);\n  }\n};\n\nmodule.exports = Condition;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/flowchart.symbol.condition.js\n// module id = 5\n// module chunks = 0","var Symbol = require('./flowchart.symbol');\nvar inherits = require('./flowchart.helpers').inherits;\n\nfunction Parallel(chart, options) {\n  var symbol = chart.paper.rect(0, 0, 0, 0);\n  options = options || {};\n  Symbol.call(this, chart, options, symbol);\n  this.path1_annotation = options.path1_annotation || '';\n  this.path2_annotation = options.path2_annotation || '';\n  this.path3_annotation = options.path3_annotation || '';\n  this.textMargin = this.getAttr('text-margin');\n  this.path1_direction = 'bottom';\n  this.path2_direction = 'right';\n  this.path3_direction = 'top';\n  this.params = options.params;\n  if (options.direction_next === 'path1' && !options[options.direction_next] && options.next) {\n    options[options.direction_next] = options.next;\n  }\n  if (options.direction_next === 'path2' && !options[options.direction_next] && options.next) {\n    options[options.direction_next] = options.next;\n  }\n  if (options.direction_next === 'path3' && !options[options.direction_next] && options.next) {\n    options[options.direction_next] = options.next;\n  }\n\n  if (options.path1 && options.direction_path1 && options.path2 && !options.direction_path2 && options.path3 && !options.direction_path3) {\n    if (options.direction_path1 === 'right') {\n      this.path2_direction = 'bottom';\n      this.path1_direction = 'right';\n      this.path3_direction = 'top';\n    } else if (options.direction_path1 === 'top') {\n      this.path2_direction = 'right';\n      this.path1_direction = 'top';\n      this.path3_direction = 'bottom';\n    } else if (options.direction_path1 === 'left') {\n      this.path2_direction = 'right';\n      this.path1_direction = 'left';\n      this.path3_direction = 'bottom';\n    } else {\n      this.path2_direction = 'right';\n      this.path1_direction = 'bottom';\n      this.path3_direction = 'top';\n    }\n  } else if (options.path1 && !options.direction_path1 && options.path2 && options.direction_path2 && options.path3 && !options.direction_path3) {\n    if (options.direction_path2 === 'right') {\n      this.path1_direction = 'bottom';\n      this.path2_direction = 'right';\n      this.path3_direction = 'top';\n    } else if (options.direction_path2 === 'left') {\n      this.path1_direction = 'bottom';\n      this.path2_direction = 'left';\n      this.path3_direction = 'right';\n    } else {\n      this.path1_direction = 'right';\n      this.path2_direction = 'bottom';\n      this.path3_direction = 'top';\n    }\n  } else if (options.path1 && !options.direction_path1 && options.path2 && !options.direction_path2 && options.path3 && options.direction_path3) {\n    if (options.direction_path2 === 'right') {\n      this.path1_direction = 'bottom';\n      this.path2_direction = 'top';\n      this.path3_direction = 'right';\n    } else if (options.direction_path2 === 'left') {\n      this.path1_direction = 'bottom';\n      this.path2_direction = 'right';\n      this.path3_direction = 'left';\n    } else {\n      this.path1_direction = 'right';\n      this.path2_direction = 'bottom';\n      this.path3_direction = 'top';\n    }\n  } else {\n    this.path1_direction = options.direction_path1;\n    this.path2_direction = options.direction_path2;\n    this.path3_direction = options.direction_path3;\n  }\n\n  this.path1_direction = this.path1_direction || 'bottom';\n  this.path2_direction = this.path2_direction || 'right';\n  this.path3_direction = this.path3_direction || 'top';\n\n  this.initialize();\n}\ninherits(Parallel, Symbol);\n\nParallel.prototype.render = function() {\n  if (this.path1_direction) {\n    this[this.path1_direction + '_symbol'] = this.path1_symbol;\n  }\n\n  if (this.path2_direction) {\n    this[this.path2_direction + '_symbol'] = this.path2_symbol;\n  }\n\n  if (this.path3_direction) {\n    this[this.path3_direction + '_symbol'] = this.path3_symbol;\n  }\n\n  var lineLength = this.getAttr('line-length');\n\n  if (this.bottom_symbol) {\n    var bottomPoint = this.getBottom();\n\n    if (!this.bottom_symbol.isPositioned) {\n      this.bottom_symbol.shiftY(this.getY() + this.height + lineLength);\n      this.bottom_symbol.setX(bottomPoint.x - this.bottom_symbol.width / 2);\n      this.bottom_symbol.isPositioned = true;\n\n      this.bottom_symbol.render();\n    }\n  }\n\n  if (this.top_symbol) {\n    var topPoint = this.getTop();\n\n    if (!this.top_symbol.isPositioned) {\n      this.top_symbol.shiftY(this.getY() - this.top_symbol.height - lineLength);\n      this.top_symbol.setX(topPoint.x + this.top_symbol.width);\n      this.top_symbol.isPositioned = true;\n\n      this.top_symbol.render();\n    }\n  }\n\n  var self = this;\n\n  if (this.left_symbol) {\n    var leftPoint = this.getLeft();\n\n    if (!this.left_symbol.isPositioned) {\n      this.left_symbol.setY(leftPoint.y - this.left_symbol.height / 2);\n      this.left_symbol.shiftX(-(this.group.getBBox().x + this.width + lineLength));\n      (function shift() {\n        var hasSymbolUnder = false;\n        var symb;\n        for (var i = 0, len = self.chart.symbols.length; i < len; i++) {\n          symb = self.chart.symbols[i];\n\n          if (!self.params['align-next'] || self.params['align-next'] !== 'no') {\n            var diff = Math.abs(symb.getCenter().x - self.left_symbol.getCenter().x);\n            if (symb.getCenter().y > self.left_symbol.getCenter().y && diff <= self.left_symbol.width / 2) {\n              hasSymbolUnder = true;\n              break;\n            }\n          }\n        }\n\n        if (hasSymbolUnder) {\n          if (self.left_symbol.symbolType === 'end') return;\n          self.left_symbol.setX(symb.getX() + symb.width + lineLength);\n          shift();\n        }\n      })();\n\n      this.left_symbol.isPositioned = true;\n\n      this.left_symbol.render();\n    }\n  }\n\n  if (this.right_symbol) {\n    var rightPoint = this.getRight();\n\n    if (!this.right_symbol.isPositioned) {\n      this.right_symbol.setY(rightPoint.y - this.right_symbol.height / 2);\n      this.right_symbol.shiftX(this.group.getBBox().x + this.width + lineLength);\n      (function shift() {\n        var hasSymbolUnder = false;\n        var symb;\n        for (var i = 0, len = self.chart.symbols.length; i < len; i++) {\n          symb = self.chart.symbols[i];\n\n          if (!self.params['align-next'] || self.params['align-next'] !== 'no') {\n            var diff = Math.abs(symb.getCenter().x - self.right_symbol.getCenter().x);\n            if (symb.getCenter().y > self.right_symbol.getCenter().y && diff <= self.right_symbol.width / 2) {\n              hasSymbolUnder = true;\n              break;\n            }\n          }\n        }\n\n        if (hasSymbolUnder) {\n          if (self.right_symbol.symbolType === 'end') return;\n          self.right_symbol.setX(symb.getX() + symb.width + lineLength);\n          shift();\n        }\n      })();\n\n      this.right_symbol.isPositioned = true;\n\n      this.right_symbol.render();\n    }\n  }\n};\n\nParallel.prototype.renderLines = function() {\n  if (this.path1_symbol) {\n    this.drawLineTo(this.path1_symbol, this.path1_annotation, this.path1_direction);\n  }\n\n  if (this.path2_symbol) {\n    this.drawLineTo(this.path2_symbol, this.path2_annotation, this.path2_direction);\n  }\n\n  if (this.path3_symbol) {\n    this.drawLineTo(this.path3_symbol, this.path3_annotation, this.path3_direction);\n  }\n};\n\nmodule.exports = Parallel;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/flowchart.symbol.parallel.js\n// module id = 6\n// module chunks = 0","var Raphael = require('raphael');\nvar defaults = require('./flowchart.helpers').defaults;\nvar defaultOptions = require('./flowchart.defaults');\nvar Condition = require('./flowchart.symbol.condition');\nvar Parallel = require('./flowchart.symbol.parallel');\n\nfunction FlowChart(container, options) {\n  options = options || {};\n\n  this.paper = new Raphael(container);\n\n  this.options = defaults(options, defaultOptions);\n\n  this.symbols = [];\n  this.lines = [];\n  this.start = null;\n}\n\nFlowChart.prototype.handle = function(symbol) {\n  if (this.symbols.indexOf(symbol) <= -1) {\n    this.symbols.push(symbol);\n  }\n\n  var flowChart = this;\n\n  if (symbol instanceof(Condition)) {\n    symbol.yes = function(nextSymbol) {\n      symbol.yes_symbol = nextSymbol;\n      if(symbol.no_symbol) {\n        symbol.pathOk = true;\n      }\n      return flowChart.handle(nextSymbol);\n    };\n    symbol.no = function(nextSymbol) {\n      symbol.no_symbol = nextSymbol;\n      if (symbol.yes_symbol) {\n        symbol.pathOk = true;\n      }\n      return flowChart.handle(nextSymbol);\n    };\n  } else if (symbol instanceof(Parallel)) {\n    symbol.path1 = function(nextSymbol) {\n      symbol.path1_symbol = nextSymbol;\n      if (symbol.path2_symbol) {\n        symbol.pathOk = true;\n      }\n      return flowChart.handle(nextSymbol);\n    };\n    symbol.path2 = function(nextSymbol) {\n      symbol.path2_symbol = nextSymbol;\n      if (symbol.path3_symbol) {\n        symbol.pathOk = true;\n      }\n      return flowChart.handle(nextSymbol);\n    };\n    symbol.path3 = function(nextSymbol) {\n      symbol.path3_symbol = nextSymbol;\n      if (symbol.path1_symbol) {\n        symbol.pathOk = true;\n      }\n      return flowChart.handle(nextSymbol);\n    };\n  } else {\n    symbol.then = function(nextSymbol) {\n      symbol.next = nextSymbol;\n      symbol.pathOk = true;\n      return flowChart.handle(nextSymbol);\n    };\n  }\n\n  return symbol;\n};\n\nFlowChart.prototype.startWith = function(symbol) {\n  this.start = symbol;\n  return this.handle(symbol);\n};\n\nFlowChart.prototype.render = function() {\n  var maxWidth = 0,\n    maxHeight = 0,\n    i = 0,\n    len = 0,\n    maxX = 0,\n    maxY = 0,\n    minX = 0,\n    minY = 0,\n    symbol,\n    line;\n\n  for (i = 0, len = this.symbols.length; i < len; i++) {\n    symbol = this.symbols[i];\n    if (symbol.width > maxWidth) {\n      maxWidth = symbol.width;\n    }\n    if (symbol.height > maxHeight) {\n      maxHeight = symbol.height;\n    }\n  }\n\n  for (i = 0, len = this.symbols.length; i < len; i++) {\n    symbol = this.symbols[i];\n    symbol.shiftX(this.options.x + (maxWidth - symbol.width)/2 + this.options['line-width']);\n    symbol.shiftY(this.options.y + (maxHeight - symbol.height)/2 + this.options['line-width']);\n  }\n\n  this.start.render();\n  // for (i = 0, len = this.symbols.length; i < len; i++) {\n  //   symbol = this.symbols[i];\n  //   symbol.render();\n  // }\n\n  for (i = 0, len = this.symbols.length; i < len; i++) {\n    symbol = this.symbols[i];\n    symbol.renderLines();\n  }\n\n  maxX = this.maxXFromLine;\n\n  var x;\n  var y;\n\n  for (i = 0, len = this.symbols.length; i < len; i++) {\n    symbol = this.symbols[i];\n    var leftX = symbol.getX()\n    x = leftX + symbol.width;\n    y = symbol.getY() + symbol.height;\n    if (leftX < minX) {\n      minX = leftX;\n    }\n    if (x > maxX) {\n      maxX = x;\n    }\n    if (y > maxY) {\n      maxY = y;\n    }\n  }\n\n  for (i = 0, len = this.lines.length; i < len; i++) {\n    line = this.lines[i].getBBox();\n    x = line.x;\n    y = line.y;\n    var x2 = line.x2;\n    var y2 = line.y2;\n    if (x < minX) {\n      minX = x;\n    }\n    if (y < minY) {\n      minY = y;\n    }\n    if (x2 > maxX) {\n      maxX = x2;\n    }\n    if (y2 > maxY) {\n      maxY = y2;\n    }\n  }\n\n  var scale = this.options['scale'];\n  var lineWidth = this.options['line-width'];\n\n  if (this.minXFromSymbols < minX) minX = this.minXFromSymbols;\n\n  if (minX < 0) minX -= lineWidth;\n  if (minY < 0) minY -= lineWidth;\n\n  var width = maxX + lineWidth - minX;\n  var height = maxY + lineWidth - minY;\n\n  this.paper.setSize(width * scale, height * scale);\n  this.paper.setViewBox(minX, minY, width, height, true);\n};\n\nFlowChart.prototype.clean = function() {\n  if (this.paper) {\n    var paperDom = this.paper.canvas;\n    paperDom.parentNode && paperDom.parentNode.removeChild(paperDom);\n  }\n};\n\nmodule.exports = FlowChart;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/flowchart.chart.js\n// module id = 7\n// module chunks = 0","// defaults\nmodule.exports = {\n  'x': 0,\n  'y': 0,\n  // 'roundness': 0,\n  'line-width': 3,\n  'line-length': 50,\n  'text-margin': 10,\n  'font-size': 14,\n  'font-color': 'black',\n  // 'font': 'normal',\n  // 'font-family': 'calibri',\n  // 'font-weight': 'normal',\n  'line-color': 'black',\n  'element-color': 'black',\n  'fill': 'white',\n  'yes-text': 'yes',\n  'no-text': 'no',\n  'arrow-end': 'block',\n  'class': 'flowchart',\n  'scale': 1,\n  'symbols': {\n    'start': {},\n    'end': {},\n    'condition': {},\n    'inputoutput': {},\n    'input': {}, //tds\n    'output': {}, //tds    \n    'operation': {},\n    'subroutine': {},\n    'parallel': {}\n  } //,\n  // 'flowstate' : {\n  //   'past' : { 'fill': '#CCCCCC', 'font-size': 12},\n  //   'current' : {'fill': 'yellow', 'font-color': 'red', 'font-weight': 'bold'},\n  //   'future' : { 'fill': '#FFFF99'},\n  //   'invalid': {'fill': '#444444'}\n  // }\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/flowchart.defaults.js\n// module id = 8\n// module chunks = 0","// add indexOf to non ECMA-262 standard compliant browsers\nif (!Array.prototype.indexOf) {\n  Array.prototype.indexOf = function (searchElement /*, fromIndex */ ) {\n    \"use strict\";\n    if (this === null) {\n      throw new TypeError();\n    }\n    var t = Object(this);\n    var len = t.length >>> 0;\n    if (len === 0) {\n      return -1;\n    }\n    var n = 0;\n    if (arguments.length > 0) {\n      n = Number(arguments[1]);\n      if (n != n) { // shortcut for verifying if it's NaN\n        n = 0;\n      } else if (n !== 0 && n != Infinity && n != -Infinity) {\n        n = (n > 0 || -1) * Math.floor(Math.abs(n));\n      }\n    }\n    if (n >= len) {\n      return -1;\n    }\n    var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);\n    for (; k < len; k++) {\n      if (k in t && t[k] === searchElement) {\n        return k;\n      }\n    }\n    return -1;\n  };\n}\n\n// add lastIndexOf to non ECMA-262 standard compliant browsers\nif (!Array.prototype.lastIndexOf) {\n  Array.prototype.lastIndexOf = function(searchElement /*, fromIndex*/) {\n    \"use strict\";\n    if (this === null) {\n      throw new TypeError();\n    }\n    var t = Object(this);\n    var len = t.length >>> 0;\n    if (len === 0) {\n      return -1;\n    }\n    var n = len;\n    if (arguments.length > 1) {\n      n = Number(arguments[1]);\n      if (n != n) {\n        n = 0;\n      } else if (n !== 0 && n != (1 / 0) && n != -(1 / 0)) {\n        n = (n > 0 || -1) * Math.floor(Math.abs(n));\n      }\n    }\n    var k = n >= 0 ? Math.min(n, len - 1) : len - Math.abs(n);\n    for (; k >= 0; k--) {\n      if (k in t && t[k] === searchElement) {\n        return k;\n      }\n    }\n    return -1;\n  };\n}\n\nif (!String.prototype.trim) {\n  String.prototype.trim = function() {\n    return this.replace(/^\\s+|\\s+$/g, '');\n  };\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/flowchart.shim.js\n// module id = 9\n// module chunks = 0","var Symbol = require('./flowchart.symbol');\nvar inherits = require('./flowchart.helpers').inherits;\n\nfunction End(chart, options) {\n  var symbol = chart.paper.rect(0, 0, 0, 0, 20);\n  options = options || {};\n  options.text = options.text || 'End';\n  Symbol.call(this, chart, options, symbol);\n}\ninherits(End, Symbol);\n\nmodule.exports = End;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/flowchart.symbol.end.js\n// module id = 10\n// module chunks = 0","var Symbol = require('./flowchart.symbol');\nvar inherits = require('./flowchart.helpers').inherits;\nvar drawAPI = require('./flowchart.functions');\nvar drawPath = drawAPI.drawPath;\n\nfunction Input(chart, options) {\n  options = options || {};\n  Symbol.call(this, chart, options);\n  this.textMargin = this.getAttr('text-margin');\n\n  this.text.attr({\n    x: this.textMargin * 3\n  });\n\n  var width = this.text.getBBox().width + 4 * this.textMargin;\n  var height = this.text.getBBox().height + 2 * this.textMargin;\n  var startX = this.textMargin;\n  var startY = height/2;\n\n  var start = {x: startX, y: startY};\n  var points = [\n    {x: startX - this.textMargin + 2 * this.textMargin, y: height},\n    {x: startX - this.textMargin + width, y: height},\n    {x: startX - this.textMargin + width + 2 * this.textMargin, y: 0},\n    {x: startX - this.textMargin, y: 0},\n    {x: startX, y: startY}\n  ];\n\n  var symbol = drawPath(chart, start, points);\n\n  symbol.attr({\n    stroke: this.getAttr('element-color'),\n    'stroke-width': this.getAttr('line-width'),\n    fill: this.getAttr('fill')\n  });\n  if (options.link) { symbol.attr('href', options.link); }\n  if (options.target) { symbol.attr('target', options.target); }\n  if (options.key) { symbol.node.id = options.key; }\n  symbol.node.setAttribute('class', this.getAttr('class'));\n\n  this.text.attr({\n    y: symbol.getBBox().height/2\n  });\n\n  this.group.push(symbol);\n  symbol.insertBefore(this.text);\n  this.symbol = symbol\n\n  this.initialize();\n}\ninherits(Input, Symbol);\n\nInput.prototype.getLeft = function() {\n  var y = this.getY() + this.group.getBBox().height/2;\n  var x = this.getX() + this.textMargin;\n  return {x: x, y: y};\n};\n\nInput.prototype.getRight = function() {\n  var y = this.getY() + this.group.getBBox().height/2;\n  var x = this.getX() + this.group.getBBox().width - this.textMargin;\n  return {x: x, y: y};\n};\n\nmodule.exports = Input;\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/flowchart.symbol.input.js\n// module id = 11\n// module chunks = 0","var Symbol = require('./flowchart.symbol');\nvar inherits = require('./flowchart.helpers').inherits;\nvar drawAPI = require('./flowchart.functions');\nvar drawPath = drawAPI.drawPath;\n\nfunction InputOutput(chart, options) {\n  options = options || {};\n  Symbol.call(this, chart, options);\n  this.textMargin = this.getAttr('text-margin');\n\n  this.text.attr({\n    x: this.textMargin * 3\n  });\n\n  var width = this.text.getBBox().width + 4 * this.textMargin;\n  var height = this.text.getBBox().height + 2 * this.textMargin;\n  var startX = this.textMargin;\n  var startY = height/2;\n\n  var start = {x: startX, y: startY};\n  var points = [\n    {x: startX - this.textMargin, y: height},\n    {x: startX - this.textMargin + width, y: height},\n    {x: startX - this.textMargin + width + 2 * this.textMargin, y: 0},\n    {x: startX - this.textMargin + 2 * this.textMargin, y: 0},\n    {x: startX, y: startY}\n  ];\n\n  var symbol = drawPath(chart, start, points);\n\n  symbol.attr({\n    stroke: this.getAttr('element-color'),\n    'stroke-width': this.getAttr('line-width'),\n    fill: this.getAttr('fill')\n  });\n  if (options.link) { symbol.attr('href', options.link); }\n  if (options.target) { symbol.attr('target', options.target); }\n  if (options.key) { symbol.node.id = options.key; }\n  symbol.node.setAttribute('class', this.getAttr('class'));\n\n  this.text.attr({\n    y: symbol.getBBox().height/2\n  });\n\n  this.group.push(symbol);\n  symbol.insertBefore(this.text);\n  this.symbol = symbol\n\n  this.initialize();\n}\ninherits(InputOutput, Symbol);\n\nInputOutput.prototype.getLeft = function() {\n  var y = this.getY() + this.group.getBBox().height/2;\n  var x = this.getX() + this.textMargin;\n  return {x: x, y: y};\n};\n\nInputOutput.prototype.getRight = function() {\n  var y = this.getY() + this.group.getBBox().height/2;\n  var x = this.getX() + this.group.getBBox().width - this.textMargin;\n  return {x: x, y: y};\n};\n\nmodule.exports = InputOutput;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/flowchart.symbol.inputoutput.js\n// module id = 12\n// module chunks = 0","var Symbol = require('./flowchart.symbol');\nvar inherits = require('./flowchart.helpers').inherits;\n\nfunction Operation(chart, options) {\n  var symbol = chart.paper.rect(0, 0, 0, 0);\n  options = options || {};\n  Symbol.call(this, chart, options, symbol);\n}\ninherits(Operation, Symbol);\n\nmodule.exports = Operation;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/flowchart.symbol.operation.js\n// module id = 13\n// module chunks = 0","var Symbol = require('./flowchart.symbol');\nvar inherits = require('./flowchart.helpers').inherits;\nvar drawAPI = require('./flowchart.functions');\nvar drawPath = drawAPI.drawPath;\n\nfunction Output(chart, options) {\n  options = options || {};\n  Symbol.call(this, chart, options);\n  this.textMargin = this.getAttr('text-margin');\n\n  this.text.attr({\n    x: this.textMargin * 3\n  });\n\n  var width = this.text.getBBox().width + 4 * this.textMargin;\n  var height = this.text.getBBox().height + 2 * this.textMargin;\n  var startX = this.textMargin;\n  var startY = height/2;\n\n  var start = {x: startX, y: startY};\n  var points = [\n    {x: startX - this.textMargin, y: height},\n    {x: startX - this.textMargin + width + 2 * this.textMargin, y: height},\n    {x: startX - this.textMargin + width, y: 0},\n    {x: startX - this.textMargin + 2 * this.textMargin, y: 0},\n    {x: startX, y: startY}\n  ];\n\n  var symbol = drawPath(chart, start, points);\n\n  symbol.attr({\n    stroke: this.getAttr('element-color'),\n    'stroke-width': this.getAttr('line-width'),\n    fill: this.getAttr('fill')\n  });\n  if (options.link) { symbol.attr('href', options.link); }\n  if (options.target) { symbol.attr('target', options.target); }\n  if (options.key) { symbol.node.id = options.key; }\n  symbol.node.setAttribute('class', this.getAttr('class'));\n\n  this.text.attr({\n    y: symbol.getBBox().height/2\n  });\n\n  this.group.push(symbol);\n  symbol.insertBefore(this.text);\n  this.symbol = symbol\n\n  this.initialize();\n}\ninherits(Output, Symbol);\n\nOutput.prototype.getLeft = function() {\n  var y = this.getY() + this.group.getBBox().height/2;\n  var x = this.getX() + this.textMargin;\n  return {x: x, y: y};\n};\n\nOutput.prototype.getRight = function() {\n  var y = this.getY() + this.group.getBBox().height/2;\n  var x = this.getX() + this.group.getBBox().width - this.textMargin;\n  return {x: x, y: y};\n};\n\nmodule.exports = Output;\n\n\n\n/*\n//var Symbol = require('./flowchart.symbol');\nvar inherits = require('./flowchart.helpers').inherits;\nvar drawAPI = require('./flowchart.functions');\nvar InputOutput = require('./flowchart.symbol.inputoutput');\nvar drawPath = drawAPI.drawPath;\n\nfunction Output(chart, options) {\n  options = options || {};\n  InputOutput.call(this, chart, options);\n\n  var width = this.text.getBBox().width + 4 * this.textMargin;\n  var height = this.text.getBBox().height + 2 * this.textMargin;\n  var startX = this.textMargin;\n  var startY = height/2;\n\n  var start = {x: startX, y: startY};\n  var points = [\n    {x: startX - this.textMargin + 2 * this.textMargin, y: height},\n    {x: startX - this.textMargin + width, y: height},\n    {x: startX - this.textMargin + width + 2 * this.textMargin, y: 0},\n    {x: startX - this.textMargin, y: 0},\n    {x: startX, y: startY}\n  ];\n\n  var symbol = drawPath(chart, start, points);\n\n  symbol.attr({\n    stroke: this.getAttr('element-color'),\n    'stroke-width': this.getAttr('line-width'),\n    fill: this.getAttr('fill')\n  });\n  if (options.link) { symbol.attr('href', options.link); }\n  if (options.target) { symbol.attr('target', options.target); }\n  if (options.key) { symbol.node.id = options.key; }\n  symbol.node.setAttribute('class', this.getAttr('class'));\n\n  this.text.attr({\n    y: symbol.getBBox().height/2\n  });\n\n  this.group.push(symbol);\n  symbol.insertBefore(this.text);\n    \n  if (this.symbol){\n    this.group.remove(this.symbol); //tds\n    this.symbol.parentNode.removeChild(this.symbol); //tds\n  }\n  this.symbol = symbol\n\n  this.initialize();\n}\ninherits(Output, InputOutput);\n\nmodule.exports = Output;\n*/\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/flowchart.symbol.output.js\n// module id = 14\n// module chunks = 0","var Symbol = require('./flowchart.symbol');\nvar inherits = require('./flowchart.helpers').inherits;\n\nfunction Start(chart, options) {\n  var symbol = chart.paper.rect(0, 0, 0, 0, 20);\n  options = options || {};\n  options.text = options.text || 'Start';\n  Symbol.call(this, chart, options, symbol);\n}\ninherits(Start, Symbol);\n\nmodule.exports = Start;\n\n// Start.prototype.render = function() {\n//   if (this.next) {\n//     var lineLength = this.chart.options.symbols[this.symbolType]['line-length'] || this.chart.options['line-length'];\n\n//     var bottomPoint = this.getBottom();\n//     var topPoint = this.next.getTop();\n\n//     if (!this.next.isPositioned) {\n//       this.next.shiftY(this.getY() + this.height + lineLength);\n//       this.next.setX(bottomPoint.x - this.next.width/2);\n//       this.next.isPositioned = true;\n\n//       this.next.render();\n//     }\n//   }\n// };\n\n// Start.prototype.renderLines = function() {\n//   if (this.next) {\n//     this.drawLineTo(this.next);\n//   }\n// };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/flowchart.symbol.start.js\n// module id = 15\n// module chunks = 0","var Symbol = require('./flowchart.symbol');\nvar inherits = require('./flowchart.helpers').inherits;\n\nfunction Subroutine(chart, options) {\n  var symbol = chart.paper.rect(0, 0, 0, 0);\n  options = options || {};\n  Symbol.call(this, chart, options, symbol);\n\n  symbol.attr({\n    width: this.text.getBBox().width + 4 * this.getAttr('text-margin')\n  });\n\n  this.text.attr({\n    'x': 2 * this.getAttr('text-margin')\n  });\n\n  var innerWrap = chart.paper.rect(0, 0, 0, 0);\n  innerWrap.attr({\n    x: this.getAttr('text-margin'),\n    stroke: this.getAttr('element-color'),\n    'stroke-width': this.getAttr('line-width'),\n    width: this.text.getBBox().width + 2 * this.getAttr('text-margin'),\n    height: this.text.getBBox().height + 2 * this.getAttr('text-margin'),\n    fill: this.getAttr('fill')\n  });\n  if (options.key) { innerWrap.node.id = options.key + 'i'; }\n\n  var font = this.getAttr('font');\n  var fontF = this.getAttr('font-family');\n  var fontW = this.getAttr('font-weight');\n\n  if (font) innerWrap.attr({ 'font': font });\n  if (fontF) innerWrap.attr({ 'font-family': fontF });\n  if (fontW) innerWrap.attr({ 'font-weight': fontW });\n\n  if (options.link) { innerWrap.attr('href', options.link); }\n  if (options.target) { innerWrap.attr('target', options.target); }\n  this.group.push(innerWrap);\n  innerWrap.insertBefore(this.text);\n\n  this.initialize();\n}\ninherits(Subroutine, Symbol);\n\nmodule.exports = Subroutine;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/flowchart.symbol.subroutine.js\n// module id = 16\n// module chunks = 0","if (typeof jQuery != 'undefined') {\n\tvar parse = require('./flowchart.parse');\n\n\t(function( $ ) {\n\t\tfunction paramFit(needle, haystack) {\n\t\t\treturn needle == haystack ||\n\t\t\t( Array.isArray(haystack) && (haystack.includes(needle) || haystack.includes(Number(needle)) ))\n\t\t}\n\t\tvar methods = {\n\t\t\tinit : function(options) {\n\t\t\t\treturn this.each(function() {\n\t\t\t\t\tvar $this = $(this);\n\t\t\t\t\tthis.chart = parse($this.text());\n\t\t\t\t\t$this.html('');\n\t\t\t\t\tthis.chart.drawSVG(this, options);\n\t\t\t\t});\n\t\t\t},\n\t\t\tsetFlowStateByParam : function(param, paramValue, newFlowState) {\n\t\t\t\treturn this.each(function() {\n\t\t\t\t\tvar chart = this.chart;\n\n\t\t\t\t\t// @todo this should be part of Symbol API\n\t\t\t\t\tvar nextSymbolKeys = ['next', 'yes', 'no', 'path1', 'path2', 'path3'];\n\n\t\t\t\t\tfor (var property in chart.symbols) {\n\t\t\t\t\t\tif (chart.symbols.hasOwnProperty(property)) {\n\t\t\t\t\t\t\tvar symbol = chart.symbols[property];\n\t\t\t\t\t\t\tvar val = symbol.params[param];\n\t\t\t\t\t\t\tif (paramFit(val, paramValue)) {\n\t\t\t\t\t\t\t\tsymbol.flowstate = newFlowState;\n\t\t\t\t\t\t\t\tfor (var nski = 0; nski < nextSymbolKeys.length; nski++) {\n\t\t\t\t\t\t\t\t\tvar nextSymbolKey = nextSymbolKeys[nski];\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tsymbol[nextSymbolKey] &&\n\t\t\t\t\t\t\t\t\t\tsymbol[nextSymbolKey]['params'] &&\n\t\t\t\t\t\t\t\t\t\tsymbol[nextSymbolKey]['params'][param] &&\n\t\t\t\t\t\t\t\t\t\tparamFit(symbol[nextSymbolKey]['params'][param], paramValue)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tsymbol.lineStyle[symbol[nextSymbolKey]['key']] = {stroke: chart.options()['flowstate'][newFlowState]['fill']};\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tchart.clean();\n\t\t\t\t\tchart.drawSVG(this);\n\t\t\t\t});\n\n\t\t\t},\n\t\t\tclearFlowState: function () {\n\t\t\t\treturn this.each(function() {\n\t\t\t\t\tvar chart = this.chart;\n\n\t\t\t\t\tfor (var property in chart.symbols) {\n\t\t\t\t\t\tif (chart.symbols.hasOwnProperty(property)) {\n\t\t\t\t\t\t\tvar node = chart.symbols[property];\n\t\t\t\t\t\t\tnode.flowstate = '';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tchart.clean();\n\t\t\t\t\tchart.drawSVG(this);\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\t$.fn.flowChart = function(methodOrOptions) {\n\t\t\tif ( methods[methodOrOptions] ) {\n\t\t\t\treturn methods[ methodOrOptions ].apply( this, Array.prototype.slice.call( arguments, 1 ));\n\t\t\t} else if ( typeof methodOrOptions === 'object' || ! methodOrOptions ) {\n\t\t\t\t// Default to \"init\"\n\t\t\t\treturn methods.init.apply( this, arguments );\n\t\t\t} else {\n\t\t\t\t$.error( 'Method ' +  methodOrOptions + ' does not exist on jQuery.flowChart' );\n\t\t\t}\n\t\t};\n\n\t})(jQuery); // eslint-disable-line\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/jquery-plugin.js\n// module id = 17\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_18__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"Raphael\"\n// module id = 18\n// module chunks = 0"],"sourceRoot":""}